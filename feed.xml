<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="https://wildthinks.org/feed.xml" rel="self" type="application/atom+xml" /><link href="https://wildthinks.org/" rel="alternate" type="text/html" /><updated>2021-02-25T18:10:16-08:00</updated><id>https://wildthinks.org/feed.xml</id><title type="html">wildthinks</title><subtitle>interactive mathematics explorations</subtitle><author><name>Heidi Dixon</name></author><entry><title type="html">Quick and Dirty Fractal App</title><link href="https://wildthinks.org/posts/fractal/" rel="alternate" type="text/html" title="Quick and Dirty Fractal App" /><published>2020-04-04T00:00:00-07:00</published><updated>2020-04-04T00:00:00-07:00</updated><id>https://wildthinks.org/posts/fractal</id><content type="html" xml:base="https://wildthinks.org/posts/fractal/">I've been really busy moving in to my new web page so not a lot of time for blogging.  Feel free to have a look around but it's mostly under construction right now.  A lot of the work is really tedious so I allowed myself a small fun project.  I've been thinking about fractals lately.  My thinking is strongly influenced by theoretical computer science and one of its most fundamental ideas is that immensely complex patterns arise from very simple generators or algorithms.  So I was thinking that fractals are a good metaphor for my website.  Also, [Mathigon](https://mathigon.org) just came out with a great new lesson on [fractals](https://mathigon.org/course/fractals/introduction) which I really enjoyed.    So I whomped together a little julia set app for fun.  It's like Bertie Bott's Every Flavour Beans.  You never know what your going to get.  Some times you just get a fart fractal.  Still, I can't stop clicking the **Again** button.

[Again](:=redraw=true) [new colors](:=color=true) [zoom in](:=zoomin=true) [zoom out](:=zoomout=true) [up](:=up=true) [down](:=down=true) [left](:=left=true) [right](:=right=true) [download pdf](:=download=true)
```javascript /playable/autoplay
//smartdown.import=//cdnjs.cloudflare.com/ajax/libs/jspdf/1.3.3/jspdf.min.js



const myDiv = this.div;
myDiv.style.width = '100%';
myDiv.style.height = '100%';
myDiv.style.margin = 'auto';
myDiv.innerHTML = `&lt;canvas id=&quot;appCanvas&quot;&gt;&lt;/canvas&gt;`

let canvas = document.getElementById(&quot;appCanvas&quot;); 
let context = canvas.getContext(&quot;2d&quot;);

canvas.width  = myDiv.offsetWidth;
canvas.height = window.innerHeight * 0.7;

let juliaSeeds = [ 
[-0.391,-0.587], 
[-0.4,-0.59], 
[-0.54, 0.54], 
[0.355, 0.355], 
[0.37, 0.1], 
[0, 0.8], 
[0.34, -0.05], 
[-0.54, 0.54], 
[0.355, 0.355], 
[0.37, 0.1],
[ -0.23697092928656072, 0.7419121059594294],
[0.10697324928270424,0.6010709065175586],
[-0.07804297167573648, 0.878422153994636],
[-0.04358606323629921, -0.6601708270598163],
[-0.7581522813239732, 0.07887261017004787],
[-0.6017411670967265, 0.5390473287347921],
[-0.19385539090162895, -0.6821881025217271],
[-0.7581636113124433, 0.17868928056086064],
[-0.4, 0.6],
[0.285,0.01]
];

let w = 64;
let maxW = 256/w;

// The maximum number of iterations per pixel
let maxiterations = w * 6;

// first we need to generate a random color scheme
let base = [0, 0, 0];  // a starting color rgb
let color_incs = [     // for each color in rgb
[0,0,0,0,0,0],             //    we have four increments which can be increasing
[0,0,0,0,0,0],             //    or decreasing
[0,0,0,0,0,0]
];


function generateColorSeed() {
  // generate random starting color
  base[0] = Math.floor(Math.random() * (maxW + 1)) * w;
  base[1] = Math.floor(Math.random() * (maxW + 1)) * w;
  base[2] = Math.floor(Math.random() * (maxW + 1)) * w;

  // randomly generate the increments
  for (let i=0; i &lt; 3; i++) {
    let inc = base[i] / w;
    for (let j=0; j &lt; 6; j++) {
      let up = Math.floor(Math.random() * 2);
      if ((inc == 0 || up) &amp;&amp; inc != w) {
        color_incs[i][j] = Math.floor(Math.random() * ((maxW + 1) - inc));
      } 
      else {
        color_incs[i][j] = -Math.floor(Math.random() * (inc + 1));
      }
      inc += color_incs[i][j];
    }
  }
}


// Now we use the seed to generate the palette
// palette is just a list of rgb colors
// we need a color for every possible iteration
let palette = [];
let paletteSize = maxiterations;

function generatePalette() {
    // Calculate a gradient
    let ri = base[0];
    let gi = base[1];
    let bi = base[2];
    for (let i=0; i &lt; paletteSize; i++) {
        palette[i] = { r:ri, g:gi, b:bi };

        if (i &lt; 32) {
          ri += color_incs[0][0];
          gi += color_incs[1][0];
          bi += color_incs[2][0];
        } else if (i &lt; 64) {
          ri += color_incs[0][1];
          gi += color_incs[1][1];
          bi += color_incs[2][1];
        } else if ( i &lt; 96) {
          ri += color_incs[0][2];
          gi += color_incs[1][2];
          bi += color_incs[2][2];
        } else if ( i &lt; 128) {
          ri += color_incs[0][3];
          gi += color_incs[1][3];
          bi += color_incs[2][3];
        } else if (i &lt; 160) {
          ri += color_incs[0][4];
          gi += color_incs[1][4];
          bi += color_incs[2][4];
        } else {
          ri += color_incs[0][5];
          gi += color_incs[1][5];
          bi += color_incs[2][5];
        }
    }
}

let zoom = 500;

// Calculate the color of a specific pixel
function julia(x, y, maxiterations, imagedata, offsetx, offsety, panx, pany, zoom, seedA, seedB) {

  let x0 = (x + offsetx + panx) / zoom;  // Convert the screen coordinate to a fractal coordinate
  let y0 = (y + offsety + pany) / zoom;

  let a = x0; // imaginary number a + bi
  let b = y0;
  let a_temp = 0;
  let b_temp = 0;

  let it = 0;
  while (it &lt; maxiterations &amp;&amp; a_temp * a_temp + b_temp * b_temp &lt;= 4) {
      a_temp = a * a - b * b + seedA;
      b_temp = 2 * a * b + seedB;
      a = a_temp;
      b = b_temp;
      it += 1;
  }

  // Get palette color based on the number of iterations
  let color;
  if (it == maxiterations) {
      color = {r:base[0],g:base[1],b:base[2]};
  } else {
      let index = Math.floor((it / (maxiterations)) * (maxiterations-1));
      color = palette[index];
  }

  // Apply the color

  let pixelindex = (y * canvas.width + x) * 4;
  imagedata.data[pixelindex] = color.r;
  imagedata.data[pixelindex+1] = color.g;
  imagedata.data[pixelindex+2] = color.b;
  imagedata.data[pixelindex+3] = 255;
}

let panx = 0;
let pany = 0;
 
// Generate the fractal image
function draw() {

  // Pan and zoom parameters
  let offsetx = -canvas.width/2;
  let offsety = -canvas.height/2;

  // Image Data (RGBA)
  let imagedata = context.createImageData(canvas.width, canvas.height);
  // Iterate over the pixels
  for (let y=0; y&lt;canvas.height; y++) {
      for (let x=0; x&lt;canvas.width; x++) {
          julia(x, y, maxiterations, imagedata, offsetx, offsety, panx, pany, zoom, seedA, seedB);
      }
  }
  context.putImageData(imagedata,0,0);
}


// all the random elements in a function so we can reseed when
// we redraw
function randomFractal() {
  panx = 0;
  pany = 0;
  [seedA, seedB] = juliaSeeds[Math.floor(Math.random() * juliaSeeds.length)];
  zoom = 400 + Math.floor(Math.random() * 1000);
  generateColorSeed();
  generatePalette();
}

function newColors() {
  generateColorSeed();
  generatePalette();
}

window.addEventListener('resize', function(event){
  canvas.width  = myDiv.offsetWidth;
  canvas.height = window.innerHeight * 0.7;
  draw();
});

smartdown.setVariable('redraw', false);
smartdown.setVariable('color', false);
smartdown.setVariable('zoomin', false);
smartdown.setVariable('zoomout', false);
smartdown.setVariable('up', false);
smartdown.setVariable('down', false);
smartdown.setVariable('left', false);
smartdown.setVariable('right', false);
smartdown.setVariable('download', false);

this.dependOn = ['redraw','color','zoomin', 'zoomout','up','down','left','right','download'];
this.depend = function() {
	if (env.redraw == true) {
		smartdown.setVariable('redraw', false);
		randomFractal();
		draw();
	}
  if (env.color == true) {
    smartdown.setVariable('color', false);
    newColors();
    draw();
  }
  if (env.zoomin == true) {
    smartdown.setVariable('zoomin', false);
    zoom += 50;
    draw();
  }
  if (env.zoomout == true) {
    smartdown.setVariable('zoomout', false);
    zoom -= 50;
    draw();
  }
  if (env.up == true) {
    smartdown.setVariable('up', false);
    pany -= 50;
    draw();
  }
  if (env.down == true) {
    smartdown.setVariable('down', false);
    pany += 50;
    draw();
  }
  if (env.left == true) {
    smartdown.setVariable('left', false);
    panx -= 50;
    draw();
  }
  if (env.right == true) {
    smartdown.setVariable('right', false);
    panx += 50;
    draw();
  }
  if (env.download == true) {
    smartdown.setVariable('download', false);
    var imgData = canvas.toDataURL(&quot;image/jpeg&quot;, 1.0);
    var pdf = new jsPDF();

    pdf.addImage(imgData, 'JPEG', 0, 0);
    pdf.save(&quot;download.pdf&quot;);
  }

}



// pick a random julia seed from a list of good seeds
// then pick a random zoom level
randomFractal();
draw();

```</content><author><name>Heidi Dixon</name></author><summary type="html">I've been really busy moving in to my new web page so not a lot of time for blogging. Feel free to have a look around but it's mostly under construction right now. A lot of the work is really tedious so I allowed myself a small fun project. I've been thinking about fractals lately. My thinking is strongly influenced by theoretical computer science and one of its most fundamental ideas is that immensely complex patterns arise from very simple generators or algorithms. So I was thinking that fractals are a good metaphor for my website. Also, [Mathigon](https://mathigon.org) just came out with a great new lesson on [fractals](https://mathigon.org/course/fractals/introduction) which I really enjoyed. So I whomped together a little julia set app for fun. It's like Bertie Bott's Every Flavour Beans. You never know what your going to get. Some times you just get a fart fractal. Still, I can't stop clicking the **Again** button. [Again](:=redraw=true) [new colors](:=color=true) [zoom in](:=zoomin=true) [zoom out](:=zoomout=true) [up](:=up=true) [down](:=down=true) [left](:=left=true) [right](:=right=true) [download pdf](:=download=true) ```javascript /playable/autoplay //smartdown.import=//cdnjs.cloudflare.com/ajax/libs/jspdf/1.3.3/jspdf.min.js const myDiv = this.div; myDiv.style.width = '100%'; myDiv.style.height = '100%'; myDiv.style.margin = 'auto'; myDiv.innerHTML = `` let canvas = document.getElementById(&quot;appCanvas&quot;); let context = canvas.getContext(&quot;2d&quot;); canvas.width = myDiv.offsetWidth; canvas.height = window.innerHeight * 0.7; let juliaSeeds = [ [-0.391,-0.587], [-0.4,-0.59], [-0.54, 0.54], [0.355, 0.355], [0.37, 0.1], [0, 0.8], [0.34, -0.05], [-0.54, 0.54], [0.355, 0.355], [0.37, 0.1], [ -0.23697092928656072, 0.7419121059594294], [0.10697324928270424,0.6010709065175586], [-0.07804297167573648, 0.878422153994636], [-0.04358606323629921, -0.6601708270598163], [-0.7581522813239732, 0.07887261017004787], [-0.6017411670967265, 0.5390473287347921], [-0.19385539090162895, -0.6821881025217271], [-0.7581636113124433, 0.17868928056086064], [-0.4, 0.6], [0.285,0.01] ]; let w = 64; let maxW = 256/w; // The maximum number of iterations per pixel let maxiterations = w * 6; // first we need to generate a random color scheme let base = [0, 0, 0]; // a starting color rgb let color_incs = [ // for each color in rgb [0,0,0,0,0,0], // we have four increments which can be increasing [0,0,0,0,0,0], // or decreasing [0,0,0,0,0,0] ]; function generateColorSeed() { // generate random starting color base[0] = Math.floor(Math.random() * (maxW + 1)) * w; base[1] = Math.floor(Math.random() * (maxW + 1)) * w; base[2] = Math.floor(Math.random() * (maxW + 1)) * w; // randomly generate the increments for (let i=0; i &lt; 3; i++) { let inc = base[i] / w; for (let j=0; j &lt; 6; j++) { let up = Math.floor(Math.random() * 2); if ((inc == 0 || up) &amp;&amp; inc != w) { color_incs[i][j] = Math.floor(Math.random() * ((maxW + 1) - inc)); } else { color_incs[i][j] = -Math.floor(Math.random() * (inc + 1)); } inc += color_incs[i][j]; } } } // Now we use the seed to generate the palette // palette is just a list of rgb colors // we need a color for every possible iteration let palette = []; let paletteSize = maxiterations; function generatePalette() { // Calculate a gradient let ri = base[0]; let gi = base[1]; let bi = base[2]; for (let i=0; i &lt; paletteSize; i++) { palette[i] = { r:ri, g:gi, b:bi }; if (i &lt; 32) { ri += color_incs[0][0]; gi += color_incs[1][0]; bi += color_incs[2][0]; } else if (i &lt; 64) { ri += color_incs[0][1]; gi += color_incs[1][1]; bi += color_incs[2][1]; } else if ( i &lt; 96) { ri += color_incs[0][2]; gi += color_incs[1][2]; bi += color_incs[2][2]; } else if ( i &lt; 128) { ri += color_incs[0][3]; gi += color_incs[1][3]; bi += color_incs[2][3]; } else if (i &lt; 160) { ri += color_incs[0][4]; gi += color_incs[1][4]; bi += color_incs[2][4]; } else { ri += color_incs[0][5]; gi += color_incs[1][5]; bi += color_incs[2][5]; } } } let zoom = 500; // Calculate the color of a specific pixel function julia(x, y, maxiterations, imagedata, offsetx, offsety, panx, pany, zoom, seedA, seedB) { let x0 = (x + offsetx + panx) / zoom; // Convert the screen coordinate to a fractal coordinate let y0 = (y + offsety + pany) / zoom; let a = x0; // imaginary number a + bi let b = y0; let a_temp = 0; let b_temp = 0; let it = 0; while (it &lt; maxiterations &amp;&amp; a_temp * a_temp + b_temp * b_temp &lt;= 4) { a_temp = a * a - b * b + seedA; b_temp = 2 * a * b + seedB; a = a_temp; b = b_temp; it += 1; } // Get palette color based on the number of iterations let color; if (it == maxiterations) { color = {r:base[0],g:base[1],b:base[2]}; } else { let index = Math.floor((it / (maxiterations)) * (maxiterations-1)); color = palette[index]; } // Apply the color let pixelindex = (y * canvas.width + x) * 4; imagedata.data[pixelindex] = color.r; imagedata.data[pixelindex+1] = color.g; imagedata.data[pixelindex+2] = color.b; imagedata.data[pixelindex+3] = 255; } let panx = 0; let pany = 0; // Generate the fractal image function draw() { // Pan and zoom parameters let offsetx = -canvas.width/2; let offsety = -canvas.height/2; // Image Data (RGBA) let imagedata = context.createImageData(canvas.width, canvas.height); // Iterate over the pixels for (let y=0; y&lt;canvas.height; y++) { for (let x=0; x&lt;canvas.width; x++) { julia(x, y, maxiterations, imagedata, offsetx, offsety, panx, pany, zoom, seedA, seedB); } } context.putImageData(imagedata,0,0); } // all the random elements in a function so we can reseed when // we redraw function randomFractal() { panx = 0; pany = 0; [seedA, seedB] = juliaSeeds[Math.floor(Math.random() * juliaSeeds.length)]; zoom = 400 + Math.floor(Math.random() * 1000); generateColorSeed(); generatePalette(); } function newColors() { generateColorSeed(); generatePalette(); } window.addEventListener('resize', function(event){ canvas.width = myDiv.offsetWidth; canvas.height = window.innerHeight * 0.7; draw(); }); smartdown.setVariable('redraw', false); smartdown.setVariable('color', false); smartdown.setVariable('zoomin', false); smartdown.setVariable('zoomout', false); smartdown.setVariable('up', false); smartdown.setVariable('down', false); smartdown.setVariable('left', false); smartdown.setVariable('right', false); smartdown.setVariable('download', false); this.dependOn = ['redraw','color','zoomin', 'zoomout','up','down','left','right','download']; this.depend = function() { if (env.redraw == true) { smartdown.setVariable('redraw', false); randomFractal(); draw(); } if (env.color == true) { smartdown.setVariable('color', false); newColors(); draw(); } if (env.zoomin == true) { smartdown.setVariable('zoomin', false); zoom += 50; draw(); } if (env.zoomout == true) { smartdown.setVariable('zoomout', false); zoom -= 50; draw(); } if (env.up == true) { smartdown.setVariable('up', false); pany -= 50; draw(); } if (env.down == true) { smartdown.setVariable('down', false); pany += 50; draw(); } if (env.left == true) { smartdown.setVariable('left', false); panx -= 50; draw(); } if (env.right == true) { smartdown.setVariable('right', false); panx += 50; draw(); } if (env.download == true) { smartdown.setVariable('download', false); var imgData = canvas.toDataURL(&quot;image/jpeg&quot;, 1.0); var pdf = new jsPDF(); pdf.addImage(imgData, 'JPEG', 0, 0); pdf.save(&quot;download.pdf&quot;); } } // pick a random julia seed from a list of good seeds // then pick a random zoom level randomFractal(); draw(); ```</summary></entry><entry><title type="html">Layout Experiment with the Chain Rule</title><link href="https://wildthinks.org/posts/chainRule/" rel="alternate" type="text/html" title="Layout Experiment with the Chain Rule" /><published>2020-03-17T00:00:00-07:00</published><updated>2020-03-17T00:00:00-07:00</updated><id>https://wildthinks.org/posts/chainRule</id><content type="html" xml:base="https://wildthinks.org/posts/chainRule/">This post is an interactive exploration of the **chain rule** from calculus.  It's a continuation of previous posts on [calculus and layouts](/posts/Layout).  I hope it gives some visual intuition for why the rule works. I've worked on the color scheme a bit.  Don't forget to mouse over the blue background formulas to see the mapping between the formulas and the model.

### The Chain Rule
So you know what the chain rule is and you know how to use it, but why does it work? We're going to work through an example and build some intuition.

# --outlinebox problem
**Problem:**
Find the derivative of $f(x) = \sin(x^2)$. 
# --outlinebox
We know that the function $f$ can be viewed as the composition of the two functions $g(x) = \sin(x)$ and $k(x) = x^2$, and we know how to take the derivative of both of these functions and apply the chain rule.  But instead let's go back and try using the definition of the derivative
$$f'(x)  =  \lim_{h \to 0}\frac{f(x+h) - f(x)}{h}.$$
For our particular function $f(x) = \sin(x^2)$, that means
$$f'(x) = \lim_{h \to 0}\frac{\sin((x + h)^2) - \sin(x^2)}{h}$$
How do we evaluate this limit?  What happens as $h$ gets very small? Next, we do some algebra on our limit.
$$
\begin{align}
f'(x) &amp; = \lim_{h \to 0}\frac{\sin((x + h)^2) - \sin(x^2)}{h}  &amp; \text{definition of derivative} \newline
&amp; = \lim_{h \to 0}\frac{\sin((x + h)^2) - \sin(x^2)}{h} \cdot   \frac{(x+h)^2 - x^2}{(x+h)^2 - x^2} &amp; \text{multiply by 1} \newline 
&amp; = \lim_{h \to 0}\frac{\sin((x + h)^2) - \sin(x^2)}{(x+h)^2 - x^2} \cdot \frac{(x+h)^2 - x^2}{h}  &amp; \text{assoc. prop. of multiplication}
\end{align}
$$
Now we have a limit that we can work with. We've taken the normal expression for the secant line
$$\frac{\sin((x + h)^2) - \sin(x^2)}{h}$$
and expressed it as the product of two new secant lines
$$\frac{\sin((x + h)^2) - \sin(x^2)}{(x+h)^2 - x^2} \cdot \frac{(x+h)^2 - x^2}{h} $$
Let's take a look at each of these three secant lines to see what's going on.
```javascript /autoplay
//smartdown.import=https://cdnjs.cloudflare.com/ajax/libs/jsxgraph/0.99.7/jsxgraphcore.js

smartdown.importCssUrl('https://cdnjs.cloudflare.com/ajax/libs/jsxgraph/0.99.7/jsxgraph.css');

const myDiv = this.div;
myDiv.style.width = '100%';
myDiv.style.height = '100%';
myDiv.style.margin = 'auto';
myDiv.innerHTML = `&lt;div id='leftCR' style='height:300px; width:32%; float:left; margin:1%; border:1px solid gray;background:#FFFFFF;border-radius:8px;'&gt;&lt;/div&gt;&lt;div id='middleCR' style='height:300px; width:33%; float:left; margin:1%; border: 1px solid gray;background:#FFFFFF;border-radius:8px;';&gt;&lt;/div&gt;&lt;/div&gt;&lt;div id='rightCR' style='height:300px; width:33%; float:left; margin:1%; border: 1px solid gray;background:#FFFFFF;border-radius:8px;';&gt;&lt;/div&gt;`;


JXG.Options.text.useMathJax = true;

let xlow = -0.5;
let xhigh = 3.5;

//////////////////////////////////////////////////////////////////////////////////

// BOARD 1 

//////////////////////////////////////////////////////////////////////////////////
board1 = JXG.JSXGraph.initBoard('leftCR', {boundingbox:[xlow,2,xhigh,-2], showCopyright:false, keepaspectratio:false, axis:false});

///////////////////////////////////////////////////////    axes

let xaxis = board1.create('axis', [[0, 0], [1,0]], 
      {name:'x', 
      withLabel: false,
      label: {
        fontSize: 20,
        position: 'rt',  // possible values are 'lft', 'rt', 'top', 'bot'
        offset: [-20, 20]   // (in pixels)
      }
      });
xaxis.removeAllTicks();
board1.create('ticks', [xaxis, 1], {
  majorHeight:10, 
  strokeColor:'#AAA',
  drawLabels:true, 
  minorTicks:0
 }
);
let yaxis = board1.create('axis', [[0, 0], [0, 1]], 
      {name:'y', 
      withLabel: false, 
      label: {
        fontSize: 20,
        position: 'rt',  // possible values are 'lft', 'rt', 'top', 'bot'
        offset: [-30, -20]   // (in pixels)
        }
      });   
yaxis.removeAllTicks();
board1.create('ticks', [yaxis, 1], {
  majorHeight:10, 
  strokeColor:'#AAA',
  drawLabels:true, 
  minorTicks:0
 }
);


///////////////////////////////////////////////////////    SECANT

let title = board1.create('text',[
  0.6 * (xhigh - xlow) + xlow,
  1 * 4 - 2,
  function() { 
    return '\\[f(x) = \\sin(x^2)\\]';
  }], {fontSize:18});


let f = function(x) { return  Math.sin(x*x); };
let x = board1.create('point', [1,0], {name:'\\[x\\]', color:'#666688', fixed:true, size:6});
let fx = board1.create('point', [
  function() { return x.X(); }, 
  function() { return f(x.X()); }], 
  {name:'', color:'#666688', fixed:true});

let graph_f = board1.create('functiongraph', [f,-10,10], {strokeColor:'#BBBBBB'});

let start_x_h = 0.65;

let x_h = board1.create('glider', 
  [x.X() + start_x_h, 0, xaxis], 
  {name:'\\[x + h\\]', size:6, color:'#EE5511', visible:true} ); 

let fx_h = board1.create('point', [
  function() { return x_h.X(); }, 
  function() { return f(x_h.X()); }], 
  {name:'', color:'#666688', fixed: true, size:3, visible:true});

let secant = board1.create('line', [fx, fx_h], {color:'#BBBBBB', strokeWidth:1, visible:true});
let segment = board1.create('segment', [fx, fx_h], {color:'#666688', strokeWidth:3, visible:true});

let secantSlope = function() { 
  if (x.X() == x_h.X()) { return &quot;undef&quot;; }
  return ((f(x.X()) - f(x_h.X()))/(x.X() - x_h.X())).toFixed(2).toString(); 
}


let secantSlopeText = board1.create('text',[
  function() { return x.X() + (x_h.X() - x.X())/2 - 0.9; },
  function() { return (f(x_h.X()) - f(x.X()))/2 + f(x.X()) - 0.1; },
  function(){ return 'slope = '+ secantSlope(); }], 
  {fontSize:12, visible:true});

let p = board1.create('point', [ 
  function() { return x_h.X(); }, 
  function() { return f(x.X());}], {visible:false});


let rise = board1.create('segment', 
  [fx_h, p], 
  {color:'black', strokeWidth:1, dash:2});

let run = board1.create('segment', 
  [fx, p], 
  {color:'black', strokeWidth:1, dash:2});

let riseText = board1.create('text', [
  function() { if (x_h.X() &gt; x.X()) { return x_h.X() + 0.1; } 
         return x_h.X() - 1.5; },
  function() { return (f(x_h.X()) - f(x.X()))/2 + f(x.X()) + 0.3; },
  function() { return '\\[\\sin((x+h)^2) - \\sin(x^2)\\]'; }], 
  {fontSize:12, visible:false});

let runText = board1.create('text', [
  function() { return x.X() + (x_h.X() - x.X())/2; },
  function() { return f(x.X()) + 0.2; },
  'h'], {fontSize:12, visible:false});

let triangle = board1.create('polygon', [fx, fx_h, p], {
  fillColor:'#55DDFF', 
  fillOpacity: 50,
  borders: {strokeColor: 'yellow'}, 
  strokeWidth:3, visible:false});

let triangleOn = function() {
  triangle.setAttribute({visible:true});
  riseText.setAttribute({visible:true});
  runText.setAttribute({visible:true});
};

let triangleOff = function() {
  triangle.setAttribute({visible:false});
  riseText.setAttribute({visible:false});
  runText.setAttribute({visible:false});
};

window.triangleOff = triangleOff;
window.triangleOn  = triangleOn;


// board1.on('update', function() {
//   const xFloor = Math.floor(x.X());
//   if ((x.X() - xFloor) &lt; 0.2) {
//     x.moveTo([xFloor, 0]);
//     return;
//   }
//   const xCeil = Math.ceil(x.X());
//   if ((xCeil - x.X()) &lt; 0.2) {
//     x.moveTo([xCeil, 0]);
//     return;
//   }  
// });


//////////////////////////////////////////////////////////////////////////////////

// BOARD 2 

//////////////////////////////////////////////////////////////////////////////////

board2 = JXG.JSXGraph.initBoard('rightCR', {boundingbox:[xlow,11,xhigh,-4], showCopyright:false, keepaspectratio:false, axis:false});
board1.addChild(board2);

///////////////////////////////////////////////////////    axes

let xaxis2 = board2.create('axis', [[0, 0], [1,0]], 
      {name:'x', 
      withLabel: false,
      label: {
        fontSize: 20,
        position: 'rt',  // possible values are 'lft', 'rt', 'top', 'bot'
        offset: [-20, 20]   // (in pixels)
      }
      });
xaxis2.removeAllTicks();
board2.create('ticks', [xaxis2, 1], {
  majorHeight:10, 
  strokeColor:'#AAA',
  drawLabels:true, 
  minorTicks:0
 }
);
let yaxis2 = board2.create('axis', [[0, 0], [0, 1]], 
      {name:'y', 
      withLabel: false, 
      label: {
        fontSize: 20,
        position: 'rt',  // possible values are 'lft', 'rt', 'top', 'bot'
        offset: [-30, -20]   // (in pixels)
        }
      });   
yaxis2.removeAllTicks();
board2.create('ticks', [yaxis2, 1], {
  majorHeight:10, 
  strokeColor:'#AAA',
  drawLabels:true, 
  minorTicks:0
 }
);

///////////////////////////////////////////////////////    SECANT 2

let title2 = board2.create('text',[
  0.6 * (xhigh - xlow) + xlow,
  1 * 15 - 4,
  function() { 
    return '\\[k(x) = x^2\\]';
  }], {fontSize:18});


let f2 = function(x) { return  x * x; };
let x2 = board2.create('point', [1,0], {name:'\\[x\\]', color:'#666688', fixed:true, size:6});
let fx2 = board2.create('point', [
  function() { return x2.X(); }, 
  function() { return f2(x.X()); }], 
  {name:'', color:'#666688', fixed:true});

let graph_f2 = board2.create('functiongraph', [f2,-10,10], {strokeColor:'#BBBBBB'});

let x_h2 = board2.create('point', [
	function() { return x_h.X(); }, 
	0], 
  {name:'\\[x + h\\]', size:6, color:'#666688', visible:true} ); 

let fx_h2 = board2.create('point', [ 
  function() { return x_h.X(); }, 
  function() { return f2(x_h.X()); }], 
  {name:'', color:'#666688', fixed: true, size:3, visible:true});

let secant2 = board2.create('line', [fx2, fx_h2], {color:'#BBBBBB', strokeWidth:1, visible:true});
let segment2 = board2.create('segment', [fx2, fx_h2], {color:'#666688', strokeWidth:3, visible:true});


let secantSlope2 = function() { 
  if (x2.X() == x_h2.X()) { return &quot;undef&quot;; }
  return ((f2(x2.X()) - f2(x_h2.X()))/(x2.X() - x_h2.X())).toFixed(2).toString(); 
}


let secantSlopeText2 = board2.create('text',[
  function() { return x2.X() + (x_h2.X() - x2.X())/2 - 0.9; },
  function() { return (f2(x_h2.X()) - f2(x2.X()))/2 + f2(x2.X()); },
  function(){ return 'slope = '+ secantSlope2(); }], 
  {fontSize:12, visible:true});


let p2 = board2.create('point', [ 
  function() { return x_h2.X(); }, 
  function() { return f2(x2.X());}], 
  {visible:false});


let rise2 = board2.create('segment', 
  [fx_h2, p2], 
  {color:'black', strokeWidth:1, dash:2});

let run2 = board2.create('segment', 
  [fx2, p2], 
  {color:'black', strokeWidth:1, dash:2});

let riseText2 = board2.create('text', [
  function() { if (x_h2.X() &gt; x2.X()) { return x_h2.X() + 0.1; } 
         return x_h2.X() - 1.5; },
  function() { return (f2(x_h2.X()) - f2(x2.X()))/2 + f2(x2.X()) + 1; },
  function() { return '\\[(x+h)^2 - x^2\\]'; }], 
  {fontSize:12, visible:false});

let runText2 = board2.create('text', [
  function() { return x2.X() + (x_h2.X() - x2.X())/2; },
  function() { return f2(x2.X()) - 0.2; },
  'h'], {fontSize:12, visible:false});

let triangle2 = board2.create('polygon', [fx2, fx_h2, p2], {
  fillColor:'#55DDFF', 
  fillOpacity: 50,
  borders: {strokeColor: 'yellow'}, 
  strokeWidth:3, visible:false});

let triangle2On = function() {
  triangle2.setAttribute({visible:true});
  riseText2.setAttribute({visible:true});
  runText2.setAttribute({visible:true});
};

let triangle2Off = function() {
  triangle2.setAttribute({visible:false});
  riseText2.setAttribute({visible:false});
  runText2.setAttribute({visible:false});
};

window.triangle2Off = triangle2Off;
window.triangle2On  = triangle2On;


//////////////////////////////////////////////////////////////////////////////////

// BOARD 3 

//////////////////////////////////////////////////////////////////////////////////


board3 = JXG.JSXGraph.initBoard('middleCR', {boundingbox:[xlow - 1,2,f2(xhigh),-2], showCopyright:false, keepaspectratio:false, axis:false});
board1.addChild(board3);

///////////////////////////////////////////////////////    axes

let xaxis3 = board3.create('axis', [[0, 0], [1,0]], 
      {name:'x', 
      withLabel: false,
      label: {
        fontSize: 20,
        position: 'rt',  // possible values are 'lft', 'rt', 'top', 'bot'
        offset: [-20, 20]   // (in pixels)
      }
      });
xaxis3.removeAllTicks();
board3.create('ticks', [xaxis3, 1], {
  majorHeight:10, 
  strokeColor:'#AAA',
  drawLabels:true, 
  minorTicks:0
 }
);
let yaxis3 = board3.create('axis', [[0, 0], [0, 1]], 
      {name:'y', 
      withLabel: false, 
      label: {
        fontSize: 20,
        position: 'rt',  // possible values are 'lft', 'rt', 'top', 'bot'
        offset: [-30, -20]   // (in pixels)
        }
      });   
yaxis3.removeAllTicks();
board3.create('ticks', [yaxis3, 1], {
  majorHeight:10, 
  strokeColor:'#AAA',
  drawLabels:true, 
  minorTicks:0
 }
);

///////////////////////////////////////////////////////    SECANT

let title3 = board3.create('text',[
  0.6 * (f2(xhigh) - xlow) + xlow,
  1 * 4 - 2,
  function() { return '\\[g(x) = \\sin(x)\\]'; }],
  {fontSize:18});

let f3 = function(x) { return  Math.sin(x); };
let x3 = board3.create('point', [f2(x.X()),0], { name:'\\[x^2\\]', color:'#666688', fixed:true, size:6});
let fx3 = board3.create('point', [
  function() { return x3.X(); }, 
  function() { return f3(x3.X()); }], {name:'', color:'#666688', fixed:true});
let graph_f3 = board3.create('functiongraph', [f3,xlow-1,f2(xhigh)], {strokeColor:'#BBBBBB'});

let x_h3 = board3.create('point', [
	function() { return f2(x_h.X()); }, 
	0], 
  {name:'\\[(x+h)^2\\]', size:6, color:'#666688', visible:true} ); 
 
let fx_h3 = board3.create('point', [ 
  function() { return x_h3.X(); }, 
  function() { return f3(x_h3.X()); }], 
  {name:'', color:'#666688', fixed: true, size:3, visible:true});

let secant3 = board3.create('line', [fx3, fx_h3], {color:'#BBBBBB', strokeWidth:1,  visible:true});
let segment3 = board3.create('segment', [fx3, fx_h3], {color:'#666688', strokeWidth:3, visible:true});


let secantSlope3 = function() { 
  if (x3.X() == x_h3.X()) { return &quot;undef&quot;; }
  return ((f3(x3.X()) - f3(x_h3.X()))/(x3.X() - x_h3.X())).toFixed(2).toString(); 
}


let secantSlopeText3 = board3.create('text',[
  function() { return x3.X() + (x_h3.X() - x3.X())/2 - 3; },
  function() { return (f3(x_h3.X()) - f3(x3.X()))/2 + f3(x3.X()) - 0.1; },
  function(){ return 'slope = '+ secantSlope3(); }], 
  {fontSize:12, visible:true});


let p3 = board3.create('point', [ 
  function() { return x_h3.X(); }, 
  function() { return f3(x3.X());}], 
  {visible:false});


let rise3 = board3.create('segment', 
  [fx_h3, p3], 
  {color:'black', strokeWidth:1, dash:2});
let run3 = board3.create('segment', 
  [fx3, p3], 
  {color:'black', strokeWidth:1, dash:2});

let riseText3 = board3.create('text', [
  function() { if (x_h3.X() &gt; x3.X()) { return x_h3.X() + 0.5; } 
         return x_h3.X() - 1.5; },
  function() { return (f3(x_h3.X()) - f3(x3.X()))/2 + f3(x3.X()) + 0.2; },
  function() { return '\\[\\sin((x+h)^2) - \\sin(x^2)\\]'; }], 
  {fontSize:12, visible:false});

let runText3 = board3.create('text', [
  function() { return x3.X() + (x_h3.X() - x3.X())/2 - 0.5; },
  function() { return f3(x3.X()) + 0.4; },
  function() { return '\\[(x+h)^2 - x^2\\]'; }], 
  {fontSize:12, visible:false});

let triangle3 = board3.create('polygon', [fx3, fx_h3, p3], {
  fillColor:'#55DDFF', 
  fillOpacity: 50,
  borders: {strokeColor: 'yellow'}, 
  strokeWidth:3, visible:false});


let triangle3On = function() {
  triangle3.setAttribute({visible:true});
  riseText3.setAttribute({visible:true});
  runText3.setAttribute({visible:true});
};

let triangle3Off = function() {
  triangle3.setAttribute({visible:false});
  riseText3.setAttribute({visible:false});
  runText3.setAttribute({visible:false});
};

window.triangle3Off = triangle3Off;
window.triangle3On  = triangle3On;

let h1 = board1.create('segment', 
  [fx, p], 
  {color:'#55DDFF', strokeWidth:6, visible:false});

let h2 = board2.create('segment', 
  [fx2, p2], 
  {color:'#55DDFF', strokeWidth:6, visible:false});

let r11 = board1.create('segment', 
  [fx_h, p], 
  {color:'#55DDFF', strokeWidth:6, visible:false});

let r12 = board3.create('segment', 
  [fx_h3, p3], 
  {color:'#55DDFF', strokeWidth:6, visible:false});

let r21 = board3.create('segment', 
  [fx3, p3], 
  {color:'#55DDFF', strokeWidth:6, visible:false});

let r22 = board2.create('segment', 
  [fx_h2, p2], 
  {color:'#55DDFF', strokeWidth:6, visible:false});


let showH = function() {
  h1.setAttribute({visible:true});
  h2.setAttribute({visible:true});
};

let hideH = function() {
  h1.setAttribute({visible:false});
  h2.setAttribute({visible:false});
};

window.showH = showH;
window.hideH = hideH;

let showR1 = function() {
  r11.setAttribute({visible:true});
  r12.setAttribute({visible:true});
};

let hideR1 = function() {
  r11.setAttribute({visible:false});
  r12.setAttribute({visible:false});
};

window.showR1 = showR1;
window.hideR1 = hideR1;

let showR2 = function() {
  r21.setAttribute({visible:true});
  r22.setAttribute({visible:true});
};

let hideR2 = function() {
  r21.setAttribute({visible:false});
  r22.setAttribute({visible:false});
};

window.showR2 = showR2;
window.hideR2 = hideR2;


////////////////////////////////////////////////////////////////////////////

let multSlope = function() { 
  if (x3.X() == x_h3.X()) { return &quot;undef&quot;; }
  const s2 = ((f2(x2.X()) - f2(x_h2.X()))/(x2.X() - x_h2.X()));
  const s3 = ((f3(x3.X()) - f3(x_h3.X()))/(x3.X() - x_h3.X()));
  return (s2 * s3).toFixed(2).toString(); 
}

let productSlopeText = board1.create('text',[
  0.45 * (xhigh - xlow) + xlow,
  0.8 * 4 - 2,
  function(){ return 'slope2 * slope3 = '+ multSlope(); }], 
  {fontSize:15, visible:false});


let goClose = function() {
  if (x_h.X() &lt; x.X()) {
    x_h.moveTo([x.X()-0.01, 0],1000);
  }
  else {
    x_h.moveTo([x.X()+0.01, 0],1000);
  }
}

let goToZero = function() {
  x_h.moveTo([x.X(), 0],200);
}

let resetSecant = function() {
  x_h.moveTo([x.X() + start_x_h, 0]);
  board1.update();
};

window.goClose = goClose;
window.goToZero = goToZero;
window.resetSecant = resetSecant;

this.sizeChanged = function() {
  console.log(myDiv.offsetWidth, myDiv.offsetHeight);
  board1.resizeContainer(myDiv.offsetWidth * 0.31, myDiv.offsetWidth * 0.33);
  board2.resizeContainer(myDiv.offsetWidth * 0.31, myDiv.offsetWidth * 0.33);
  board3.resizeContainer(myDiv.offsetWidth * 0.31, myDiv.offsetWidth * 0.33);
};

this.sizeChanged();

smartdown.setVariable('slopeProduct', multSlope());

board1.on('update', function() {
  smartdown.setVariable('slopeProduct', multSlope());
});

```

#### --outlinebox outer1


#### --outlinebox left1
$$\frac{\sin((x + h)^2) - \sin(x^2)}{h}$$
#### --outlinebox

#### --outlinebox middle1
$$\frac{\sin((x + h)^2) - \sin(x^2)}{(x + h)^2 - x^2}$$
#### --outlinebox

#### --outlinebox right1
$$\frac{(x + h)^2 - x^2}{h} $$
#### --outlinebox
#### --outlinebox





```javascript /autoplay

smartdown.importCssCode(
`

.highlightOnWide {
  background-color: #55DDFF;
  padding: 16px;
  border-radius: 5px;
  border: 1px solid #66CCEE;
}

.highlightOffWide {
  background-color: #EEF9FF;
  padding: 16px;
  border-radius: 5px;
  border: 1px solid #DDE9EE;
}

.highlightOnNarrow {
  background-color: #55DDFF;
  padding: 2px 6px;
  border-radius: 5px;
  border: 1px solid #88CCEE;
}

.highlightOffNarrow {
  background-color: #EEF9FF;
  padding: 2px 6px;
  border-radius: 5px;
  border: 1px solid #DDE9EE;
}
.outer {

}

.left {
  font-size: 18px; 
}

.middle {
  font-size: 18px;
}

.right {
  font-size: 18px;
}


@media (min-width: 800px) {
  .outer {
      height: 10vh;   
  }

  .left {
    width: 32%;
    display: inline-block;
    vertical-align: top;
  }

  .middle {
    width: 32%;
    display: inline-block;
    vertical-align: top;
  }

  .right {
    width: 32%;
    display: inline-block;
    vertical-align: top;
  }
}
`);


// grab the three caption divs and change their css
const outer = document.getElementById('outer1');
const left = document.getElementById('left1');
const middle = document.getElementById('middle1');
const right = document.getElementById('right1');

outer.classList.remove('decoration-outlinebox');
left.classList.remove('decoration-outlinebox');
middle.classList.remove('decoration-outlinebox');
right.classList.remove('decoration-outlinebox');

outer.classList.add('outer');
left.classList.add('left');
middle.classList.add('left');
right.classList.add('right');


// set up highlight mapping for formulas.  connect them with their
// model highlight
const formula1 = document.getElementById('MathJax-Element-12-Frame');
formula1.onmouseover = logMouseOver;
formula1.onmouseout = logMouseOut;
formula1.classList.add('highlightOffWide');

function logMouseOver() {
  formula1.classList.remove('highlightOffWide');
  formula1.classList.add('highlightOnWide');
  window.triangleOn();
}

function logMouseOut() {
  formula1.classList.remove('highlightOnWide');
  formula1.classList.add('highlightOffWide');
  triangleOff();
}

const formula2 = document.getElementById('MathJax-Element-13-Frame');
formula2.onmouseover = logMouseOver2;
formula2.onmouseout = logMouseOut2;
formula2.classList.add('highlightOffWide');

function logMouseOver2() {
  formula2.classList.remove('highlightOffWide');
  formula2.classList.add('highlightOnWide');
  window.triangle3On();
}

function logMouseOut2() {
  formula2.classList.remove('highlightOnWide');
  formula2.classList.add('highlightOffWide');
  triangle3Off();
}

const formula3 = document.getElementById('MathJax-Element-14-Frame');
formula3.onmouseover = logMouseOver3;
formula3.onmouseout = logMouseOut3;
formula3.classList.add('highlightOffWide');

function logMouseOver3() {
  formula3.classList.remove('highlightOffWide');
  formula3.classList.add('highlightOnWide');
  window.triangle2On();
}

function logMouseOut3() {
  formula3.classList.remove('highlightOnWide');
  formula3.classList.add('highlightOffWide');
  triangle2Off();
}

const formula4 = document.getElementById('MathJax-Element-15-Frame');
formula4.onmouseover = logMouseOver4;
formula4.onmouseout = logMouseOut4;
formula4.classList.add('highlightOffNarrow');

function logMouseOver4() {
  formula4.classList.remove('highlightOffNarrow');
  formula4.classList.add('highlightOnNarrow');
  window.showH();
}

function logMouseOut4() {
  formula4.classList.remove('highlightOnNarrow');
  formula4.classList.add('highlightOffNarrow');
  window.hideH();
}

const formula5 = document.getElementById('MathJax-Element-16-Frame');
formula5.onmouseover = logMouseOver5;
formula5.onmouseout = logMouseOut5;
formula5.classList.add('highlightOffNarrow');

function logMouseOver5() {
  formula5.classList.remove('highlightOffNarrow');
  formula5.classList.add('highlightOnNarrow');
  window.showR1();
}

function logMouseOut5() {
  formula5.classList.remove('highlightOnNarrow');
  formula5.classList.add('highlightOffNarrow');
  window.hideR1();
}

const formula6 = document.getElementById('MathJax-Element-17-Frame');
formula6.onmouseover = logMouseOver6;
formula6.onmouseout = logMouseOut6;
formula6.classList.add('highlightOffNarrow');

function logMouseOver6() {
  formula6.classList.remove('highlightOffNarrow');
  formula6.classList.add('highlightOnNarrow');
  window.showR2();
}

function logMouseOut6() {
  formula6.classList.remove('highlightOnNarrow');
  formula6.classList.add('highlightOffNarrow');
  window.hideR2();
}


// code for the limit buttons
smartdown.setVariable('close', false);
smartdown.setVariable('gotozero', false);
smartdown.setVariable('reset', false);

this.dependOn = ['close', 'gotozero', 'reset'];
this.depend = function() {
  if (env.close == true) {
    smartdown.setVariable('close',false);
    window.goClose();
  }
  if (env.gotozero == true) {
    smartdown.setVariable('gotozero', false);
    window.goToZero();
  }
  if (env.reset == true) {
    smartdown.setVariable('reset', false);
    window.resetSecant();
    }
};
```

#### --outlinebox outer2
#### --outlinebox left2
[*h* close to 0](:=close=true) [*h* all the way to 0](:=gotozero=true) [Reset](:=reset=true) 
You can also drag the orange dot in the leftmost box. 

[Guided Tour](:=t1=true)
#### --outlinebox
#### --outlinebox right2

# :::: d1
Let's look at some of these quantities in our secants $h$, $\sin((x + h)^2) - \sin(x^2)$, and $(x + h)^2 - x^2$.
[Close](::d1) [Next](:=t2=true)
# ::::

# :::: d2
Notice that the product of slopes in the right two boxes is equal to the slope in the first box. Try dragging the orange dot in the first box to see different values.
[slope2 * slope3](:!slopeProduct)
[Back](:=t1=true) [Next](:=t3=true)
# ::::



# :::: d3
In the right most box, as $h$ goes to $0$, we know how to evaluate this limit. It's the derivative of $k(x) = x^2$.
$$\lim_{h \to 0}\frac{(x + h)^2 - x^2}{h} = 2x$$
[Back](:=t2=true) [Next](:=t4=true)
# ::::

# :::: d4
In the middle box, as $h$ goes to $0$ the secant gets close to a tangent line on the function $g(x) = \sin(x)$, but it's evaluated at $x^2$, not $x$. The derivative of the $\sin$ is the $\cos$ so we have
$$\lim_{h \to 0}\frac{\sin((x + h)^2) - \sin(x^2)}{(x + h)^2 - x^2} = \cos(x^2)$$
[Back](:=t3=true) [Next](:=t5=true)
# ::::

# :::: d5
When $h=0$ the slopes are all are undefined.  But this is ok.  We're taking the limit so we only care about what happens when $h$ close to $0$.
[Back](:=t4=true) [Next](:=t6=true)
# ::::

# :::: d6
But there is a problem. The value of $(x+h)^2 - x^2$ could be zero in other places then $h=0$.  For example, if $x=1$ and $h=-2$ the slope of this secant is undefined. This can be solved with a delta epsilon argument.  [See argument](https://en.wikipedia.org/wiki/Chain_rule#First_proof)
[Back](:=t5=true) [Next](:=t7=true)
# ::::

# :::: d7
We can conclude that the derivative of our function $f(x) = \sin(x^2)$ is 
$$f'(x) = \cos(x^2) \cdot 2x$$
[Back](:=t6=true) [Close](::d7)
# ::::

#### --outlinebox
#### --outlinebox


# :::: secant1
This is the standard secant line from the definition of the derivative that we don't know how to solve. 
# ::::

# :::: secant2
This is a secant line on the graph of $g(x) = \sin(x)$, but the change in the $x$ value is different here. Instead of changing by $h$, it changes by $(x + h)^2 - x^2$.
# ::::

# :::: secant3
This is the secant line on the graph of $k(x) = x^2$. 
# ::::





```javascript /autoplay

smartdown.importCssCode(
`
.outer2 {
  height: 25vh;
}

.left2 {
  padding: 10px; 
  font-size: 18px;
}

.right2 {
  font-size: 18px;
  border: 2px solid gray;
  background-color: #FFFFFF;
  border-radius: 10px;
  padding: 20px;
}


@media (min-width: 800px) {
  .outer2 {
   
  }

  .left2 {
    width: 30%;
    height: 100%;
    display: inline-block;
    vertical-align: top;
  }

  .right2 {
    width: 68%;
    height: 100%;
    display: inline-block;
    vertical-align: top; 
    overflow: scroll;
  }
}
`);


const outer = document.getElementById('outer2');
const left = document.getElementById('left2');
const right = document.getElementById('right2');

outer.classList.remove('decoration-outlinebox');
left.classList.remove('decoration-outlinebox');
right.classList.remove('decoration-outlinebox');

outer.classList.add('outer2');
left.classList.add('left2');
right.classList.add('right2');


```


```javascript /autoplay
// these are the transitions for the guided tour

smartdown.setVariable('t1', false);
smartdown.setVariable('t2', false);
smartdown.setVariable('t3', false);
smartdown.setVariable('t4', false);
smartdown.setVariable('t5', false);
smartdown.setVariable('t6', false);
smartdown.setVariable('t7', false);


this.dependOn = ['t1', 't2', 't3', 't4', 't5', 't6', 't7'];
this.depend = function() {
  if (env.t1 == true) {
    console.log('t1 is true');
    smartdown.setVariable('t1',false);
    smartdown.showDisclosure('d1', '', 'transparent');
    smartdown.hideDisclosure('d2', '', 'transparent');
    smartdown.hideDisclosure('d3', '', 'transparent');
    smartdown.hideDisclosure('d4', '', 'transparent');
    smartdown.setVariable('t1',false);
  }
  if (env.t2 == true) {
    smartdown.setVariable('t2', false);
    smartdown.showDisclosure('d2', '', 'transparent');
    smartdown.hideDisclosure('d1', '', 'transparent');  
    smartdown.hideDisclosure('d3', '', 'transparent');  
  }
  if (env.t3 == true) {
    smartdown.setVariable('t3', false);
    smartdown.showDisclosure('d3', '', 'transparent');
    smartdown.hideDisclosure('d2', '', 'transparent');  
    smartdown.hideDisclosure('d4', '', 'transparent');  
  }
  if (env.t4 == true) {
    smartdown.setVariable('t4', false);
    smartdown.showDisclosure('d4', '', 'transparent');
    smartdown.hideDisclosure('d3', '', 'transparent');  
    smartdown.hideDisclosure('d5', '', 'transparent');  
  }
  if (env.t5 == true) {
    smartdown.setVariable('t5', false);
    smartdown.showDisclosure('d5', '', 'transparent');
    smartdown.hideDisclosure('d4', '', 'transparent');  
    smartdown.hideDisclosure('d6', '', 'transparent');  
  }
  if (env.t6 == true) {
    smartdown.setVariable('t6', false);
    smartdown.showDisclosure('d6', '', 'transparent');
    smartdown.hideDisclosure('d5', '', '');  
    smartdown.hideDisclosure('d7', '', '');  
  }
  if (env.t7 == true) {
    smartdown.setVariable('t7', false);
    smartdown.showDisclosure('d7', '', 'transparent');
    smartdown.hideDisclosure('d6', '', '');  
  }
};
 
```</content><author><name>Heidi Dixon</name></author><summary type="html">This post is an interactive exploration of the **chain rule** from calculus. It's a continuation of previous posts on [calculus and layouts](/posts/Layout). I hope it gives some visual intuition for why the rule works. I've worked on the color scheme a bit. Don't forget to mouse over the blue background formulas to see the mapping between the formulas and the model. ### The Chain Rule So you know what the chain rule is and you know how to use it, but why does it work? We're going to work through an example and build some intuition. # --outlinebox problem **Problem:** Find the derivative of $f(x) = \sin(x^2)$. # --outlinebox We know that the function $f$ can be viewed as the composition of the two functions $g(x) = \sin(x)$ and $k(x) = x^2$, and we know how to take the derivative of both of these functions and apply the chain rule. But instead let's go back and try using the definition of the derivative $$f'(x) = \lim_{h \to 0}\frac{f(x+h) - f(x)}{h}.$$ For our particular function $f(x) = \sin(x^2)$, that means $$f'(x) = \lim_{h \to 0}\frac{\sin((x + h)^2) - \sin(x^2)}{h}$$ How do we evaluate this limit? What happens as $h$ gets very small? Next, we do some algebra on our limit. $$ \begin{align} f'(x) &amp; = \lim_{h \to 0}\frac{\sin((x + h)^2) - \sin(x^2)}{h} &amp; \text{definition of derivative} \newline &amp; = \lim_{h \to 0}\frac{\sin((x + h)^2) - \sin(x^2)}{h} \cdot \frac{(x+h)^2 - x^2}{(x+h)^2 - x^2} &amp; \text{multiply by 1} \newline &amp; = \lim_{h \to 0}\frac{\sin((x + h)^2) - \sin(x^2)}{(x+h)^2 - x^2} \cdot \frac{(x+h)^2 - x^2}{h} &amp; \text{assoc. prop. of multiplication} \end{align} $$ Now we have a limit that we can work with. We've taken the normal expression for the secant line $$\frac{\sin((x + h)^2) - \sin(x^2)}{h}$$ and expressed it as the product of two new secant lines $$\frac{\sin((x + h)^2) - \sin(x^2)}{(x+h)^2 - x^2} \cdot \frac{(x+h)^2 - x^2}{h} $$ Let's take a look at each of these three secant lines to see what's going on. ```javascript /autoplay //smartdown.import=https://cdnjs.cloudflare.com/ajax/libs/jsxgraph/0.99.7/jsxgraphcore.js smartdown.importCssUrl('https://cdnjs.cloudflare.com/ajax/libs/jsxgraph/0.99.7/jsxgraph.css'); const myDiv = this.div; myDiv.style.width = '100%'; myDiv.style.height = '100%'; myDiv.style.margin = 'auto'; myDiv.innerHTML = ``; JXG.Options.text.useMathJax = true; let xlow = -0.5; let xhigh = 3.5; ////////////////////////////////////////////////////////////////////////////////// // BOARD 1 ////////////////////////////////////////////////////////////////////////////////// board1 = JXG.JSXGraph.initBoard('leftCR', {boundingbox:[xlow,2,xhigh,-2], showCopyright:false, keepaspectratio:false, axis:false}); /////////////////////////////////////////////////////// axes let xaxis = board1.create('axis', [[0, 0], [1,0]], {name:'x', withLabel: false, label: { fontSize: 20, position: 'rt', // possible values are 'lft', 'rt', 'top', 'bot' offset: [-20, 20] // (in pixels) } }); xaxis.removeAllTicks(); board1.create('ticks', [xaxis, 1], { majorHeight:10, strokeColor:'#AAA', drawLabels:true, minorTicks:0 } ); let yaxis = board1.create('axis', [[0, 0], [0, 1]], {name:'y', withLabel: false, label: { fontSize: 20, position: 'rt', // possible values are 'lft', 'rt', 'top', 'bot' offset: [-30, -20] // (in pixels) } }); yaxis.removeAllTicks(); board1.create('ticks', [yaxis, 1], { majorHeight:10, strokeColor:'#AAA', drawLabels:true, minorTicks:0 } ); /////////////////////////////////////////////////////// SECANT let title = board1.create('text',[ 0.6 * (xhigh - xlow) + xlow, 1 * 4 - 2, function() { return '\\[f(x) = \\sin(x^2)\\]'; }], {fontSize:18}); let f = function(x) { return Math.sin(x*x); }; let x = board1.create('point', [1,0], {name:'\\[x\\]', color:'#666688', fixed:true, size:6}); let fx = board1.create('point', [ function() { return x.X(); }, function() { return f(x.X()); }], {name:'', color:'#666688', fixed:true}); let graph_f = board1.create('functiongraph', [f,-10,10], {strokeColor:'#BBBBBB'}); let start_x_h = 0.65; let x_h = board1.create('glider', [x.X() + start_x_h, 0, xaxis], {name:'\\[x + h\\]', size:6, color:'#EE5511', visible:true} ); let fx_h = board1.create('point', [ function() { return x_h.X(); }, function() { return f(x_h.X()); }], {name:'', color:'#666688', fixed: true, size:3, visible:true}); let secant = board1.create('line', [fx, fx_h], {color:'#BBBBBB', strokeWidth:1, visible:true}); let segment = board1.create('segment', [fx, fx_h], {color:'#666688', strokeWidth:3, visible:true}); let secantSlope = function() { if (x.X() == x_h.X()) { return &quot;undef&quot;; } return ((f(x.X()) - f(x_h.X()))/(x.X() - x_h.X())).toFixed(2).toString(); } let secantSlopeText = board1.create('text',[ function() { return x.X() + (x_h.X() - x.X())/2 - 0.9; }, function() { return (f(x_h.X()) - f(x.X()))/2 + f(x.X()) - 0.1; }, function(){ return 'slope = '+ secantSlope(); }], {fontSize:12, visible:true}); let p = board1.create('point', [ function() { return x_h.X(); }, function() { return f(x.X());}], {visible:false}); let rise = board1.create('segment', [fx_h, p], {color:'black', strokeWidth:1, dash:2}); let run = board1.create('segment', [fx, p], {color:'black', strokeWidth:1, dash:2}); let riseText = board1.create('text', [ function() { if (x_h.X() &gt; x.X()) { return x_h.X() + 0.1; } return x_h.X() - 1.5; }, function() { return (f(x_h.X()) - f(x.X()))/2 + f(x.X()) + 0.3; }, function() { return '\\[\\sin((x+h)^2) - \\sin(x^2)\\]'; }], {fontSize:12, visible:false}); let runText = board1.create('text', [ function() { return x.X() + (x_h.X() - x.X())/2; }, function() { return f(x.X()) + 0.2; }, 'h'], {fontSize:12, visible:false}); let triangle = board1.create('polygon', [fx, fx_h, p], { fillColor:'#55DDFF', fillOpacity: 50, borders: {strokeColor: 'yellow'}, strokeWidth:3, visible:false}); let triangleOn = function() { triangle.setAttribute({visible:true}); riseText.setAttribute({visible:true}); runText.setAttribute({visible:true}); }; let triangleOff = function() { triangle.setAttribute({visible:false}); riseText.setAttribute({visible:false}); runText.setAttribute({visible:false}); }; window.triangleOff = triangleOff; window.triangleOn = triangleOn; // board1.on('update', function() { // const xFloor = Math.floor(x.X()); // if ((x.X() - xFloor) x2.X()) { return x_h2.X() + 0.1; } return x_h2.X() - 1.5; }, function() { return (f2(x_h2.X()) - f2(x2.X()))/2 + f2(x2.X()) + 1; }, function() { return '\\[(x+h)^2 - x^2\\]'; }], {fontSize:12, visible:false}); let runText2 = board2.create('text', [ function() { return x2.X() + (x_h2.X() - x2.X())/2; }, function() { return f2(x2.X()) - 0.2; }, 'h'], {fontSize:12, visible:false}); let triangle2 = board2.create('polygon', [fx2, fx_h2, p2], { fillColor:'#55DDFF', fillOpacity: 50, borders: {strokeColor: 'yellow'}, strokeWidth:3, visible:false}); let triangle2On = function() { triangle2.setAttribute({visible:true}); riseText2.setAttribute({visible:true}); runText2.setAttribute({visible:true}); }; let triangle2Off = function() { triangle2.setAttribute({visible:false}); riseText2.setAttribute({visible:false}); runText2.setAttribute({visible:false}); }; window.triangle2Off = triangle2Off; window.triangle2On = triangle2On; ////////////////////////////////////////////////////////////////////////////////// // BOARD 3 ////////////////////////////////////////////////////////////////////////////////// board3 = JXG.JSXGraph.initBoard('middleCR', {boundingbox:[xlow - 1,2,f2(xhigh),-2], showCopyright:false, keepaspectratio:false, axis:false}); board1.addChild(board3); /////////////////////////////////////////////////////// axes let xaxis3 = board3.create('axis', [[0, 0], [1,0]], {name:'x', withLabel: false, label: { fontSize: 20, position: 'rt', // possible values are 'lft', 'rt', 'top', 'bot' offset: [-20, 20] // (in pixels) } }); xaxis3.removeAllTicks(); board3.create('ticks', [xaxis3, 1], { majorHeight:10, strokeColor:'#AAA', drawLabels:true, minorTicks:0 } ); let yaxis3 = board3.create('axis', [[0, 0], [0, 1]], {name:'y', withLabel: false, label: { fontSize: 20, position: 'rt', // possible values are 'lft', 'rt', 'top', 'bot' offset: [-30, -20] // (in pixels) } }); yaxis3.removeAllTicks(); board3.create('ticks', [yaxis3, 1], { majorHeight:10, strokeColor:'#AAA', drawLabels:true, minorTicks:0 } ); /////////////////////////////////////////////////////// SECANT let title3 = board3.create('text',[ 0.6 * (f2(xhigh) - xlow) + xlow, 1 * 4 - 2, function() { return '\\[g(x) = \\sin(x)\\]'; }], {fontSize:18}); let f3 = function(x) { return Math.sin(x); }; let x3 = board3.create('point', [f2(x.X()),0], { name:'\\[x^2\\]', color:'#666688', fixed:true, size:6}); let fx3 = board3.create('point', [ function() { return x3.X(); }, function() { return f3(x3.X()); }], {name:'', color:'#666688', fixed:true}); let graph_f3 = board3.create('functiongraph', [f3,xlow-1,f2(xhigh)], {strokeColor:'#BBBBBB'}); let x_h3 = board3.create('point', [ function() { return f2(x_h.X()); }, 0], {name:'\\[(x+h)^2\\]', size:6, color:'#666688', visible:true} ); let fx_h3 = board3.create('point', [ function() { return x_h3.X(); }, function() { return f3(x_h3.X()); }], {name:'', color:'#666688', fixed: true, size:3, visible:true}); let secant3 = board3.create('line', [fx3, fx_h3], {color:'#BBBBBB', strokeWidth:1, visible:true}); let segment3 = board3.create('segment', [fx3, fx_h3], {color:'#666688', strokeWidth:3, visible:true}); let secantSlope3 = function() { if (x3.X() == x_h3.X()) { return &quot;undef&quot;; } return ((f3(x3.X()) - f3(x_h3.X()))/(x3.X() - x_h3.X())).toFixed(2).toString(); } let secantSlopeText3 = board3.create('text',[ function() { return x3.X() + (x_h3.X() - x3.X())/2 - 3; }, function() { return (f3(x_h3.X()) - f3(x3.X()))/2 + f3(x3.X()) - 0.1; }, function(){ return 'slope = '+ secantSlope3(); }], {fontSize:12, visible:true}); let p3 = board3.create('point', [ function() { return x_h3.X(); }, function() { return f3(x3.X());}], {visible:false}); let rise3 = board3.create('segment', [fx_h3, p3], {color:'black', strokeWidth:1, dash:2}); let run3 = board3.create('segment', [fx3, p3], {color:'black', strokeWidth:1, dash:2}); let riseText3 = board3.create('text', [ function() { if (x_h3.X() &gt; x3.X()) { return x_h3.X() + 0.5; } return x_h3.X() - 1.5; }, function() { return (f3(x_h3.X()) - f3(x3.X()))/2 + f3(x3.X()) + 0.2; }, function() { return '\\[\\sin((x+h)^2) - \\sin(x^2)\\]'; }], {fontSize:12, visible:false}); let runText3 = board3.create('text', [ function() { return x3.X() + (x_h3.X() - x3.X())/2 - 0.5; }, function() { return f3(x3.X()) + 0.4; }, function() { return '\\[(x+h)^2 - x^2\\]'; }], {fontSize:12, visible:false}); let triangle3 = board3.create('polygon', [fx3, fx_h3, p3], { fillColor:'#55DDFF', fillOpacity: 50, borders: {strokeColor: 'yellow'}, strokeWidth:3, visible:false}); let triangle3On = function() { triangle3.setAttribute({visible:true}); riseText3.setAttribute({visible:true}); runText3.setAttribute({visible:true}); }; let triangle3Off = function() { triangle3.setAttribute({visible:false}); riseText3.setAttribute({visible:false}); runText3.setAttribute({visible:false}); }; window.triangle3Off = triangle3Off; window.triangle3On = triangle3On; let h1 = board1.create('segment', [fx, p], {color:'#55DDFF', strokeWidth:6, visible:false}); let h2 = board2.create('segment', [fx2, p2], {color:'#55DDFF', strokeWidth:6, visible:false}); let r11 = board1.create('segment', [fx_h, p], {color:'#55DDFF', strokeWidth:6, visible:false}); let r12 = board3.create('segment', [fx_h3, p3], {color:'#55DDFF', strokeWidth:6, visible:false}); let r21 = board3.create('segment', [fx3, p3], {color:'#55DDFF', strokeWidth:6, visible:false}); let r22 = board2.create('segment', [fx_h2, p2], {color:'#55DDFF', strokeWidth:6, visible:false}); let showH = function() { h1.setAttribute({visible:true}); h2.setAttribute({visible:true}); }; let hideH = function() { h1.setAttribute({visible:false}); h2.setAttribute({visible:false}); }; window.showH = showH; window.hideH = hideH; let showR1 = function() { r11.setAttribute({visible:true}); r12.setAttribute({visible:true}); }; let hideR1 = function() { r11.setAttribute({visible:false}); r12.setAttribute({visible:false}); }; window.showR1 = showR1; window.hideR1 = hideR1; let showR2 = function() { r21.setAttribute({visible:true}); r22.setAttribute({visible:true}); }; let hideR2 = function() { r21.setAttribute({visible:false}); r22.setAttribute({visible:false}); }; window.showR2 = showR2; window.hideR2 = hideR2; //////////////////////////////////////////////////////////////////////////// let multSlope = function() { if (x3.X() == x_h3.X()) { return &quot;undef&quot;; } const s2 = ((f2(x2.X()) - f2(x_h2.X()))/(x2.X() - x_h2.X())); const s3 = ((f3(x3.X()) - f3(x_h3.X()))/(x3.X() - x_h3.X())); return (s2 * s3).toFixed(2).toString(); } let productSlopeText = board1.create('text',[ 0.45 * (xhigh - xlow) + xlow, 0.8 * 4 - 2, function(){ return 'slope2 * slope3 = '+ multSlope(); }], {fontSize:15, visible:false}); let goClose = function() { if (x_h.X() &lt; x.X()) { x_h.moveTo([x.X()-0.01, 0],1000); } else { x_h.moveTo([x.X()+0.01, 0],1000); } } let goToZero = function() { x_h.moveTo([x.X(), 0],200); } let resetSecant = function() { x_h.moveTo([x.X() + start_x_h, 0]); board1.update(); }; window.goClose = goClose; window.goToZero = goToZero; window.resetSecant = resetSecant; this.sizeChanged = function() { console.log(myDiv.offsetWidth, myDiv.offsetHeight); board1.resizeContainer(myDiv.offsetWidth * 0.31, myDiv.offsetWidth * 0.33); board2.resizeContainer(myDiv.offsetWidth * 0.31, myDiv.offsetWidth * 0.33); board3.resizeContainer(myDiv.offsetWidth * 0.31, myDiv.offsetWidth * 0.33); }; this.sizeChanged(); smartdown.setVariable('slopeProduct', multSlope()); board1.on('update', function() { smartdown.setVariable('slopeProduct', multSlope()); }); ``` #### --outlinebox outer1 #### --outlinebox left1 $$\frac{\sin((x + h)^2) - \sin(x^2)}{h}$$ #### --outlinebox #### --outlinebox middle1 $$\frac{\sin((x + h)^2) - \sin(x^2)}{(x + h)^2 - x^2}$$ #### --outlinebox #### --outlinebox right1 $$\frac{(x + h)^2 - x^2}{h} $$ #### --outlinebox #### --outlinebox ```javascript /autoplay smartdown.importCssCode( ` .highlightOnWide { background-color: #55DDFF; padding: 16px; border-radius: 5px; border: 1px solid #66CCEE; } .highlightOffWide { background-color: #EEF9FF; padding: 16px; border-radius: 5px; border: 1px solid #DDE9EE; } .highlightOnNarrow { background-color: #55DDFF; padding: 2px 6px; border-radius: 5px; border: 1px solid #88CCEE; } .highlightOffNarrow { background-color: #EEF9FF; padding: 2px 6px; border-radius: 5px; border: 1px solid #DDE9EE; } .outer { } .left { font-size: 18px; } .middle { font-size: 18px; } .right { font-size: 18px; } @media (min-width: 800px) { .outer { height: 10vh; } .left { width: 32%; display: inline-block; vertical-align: top; } .middle { width: 32%; display: inline-block; vertical-align: top; } .right { width: 32%; display: inline-block; vertical-align: top; } } `); // grab the three caption divs and change their css const outer = document.getElementById('outer1'); const left = document.getElementById('left1'); const middle = document.getElementById('middle1'); const right = document.getElementById('right1'); outer.classList.remove('decoration-outlinebox'); left.classList.remove('decoration-outlinebox'); middle.classList.remove('decoration-outlinebox'); right.classList.remove('decoration-outlinebox'); outer.classList.add('outer'); left.classList.add('left'); middle.classList.add('left'); right.classList.add('right'); // set up highlight mapping for formulas. connect them with their // model highlight const formula1 = document.getElementById('MathJax-Element-12-Frame'); formula1.onmouseover = logMouseOver; formula1.onmouseout = logMouseOut; formula1.classList.add('highlightOffWide'); function logMouseOver() { formula1.classList.remove('highlightOffWide'); formula1.classList.add('highlightOnWide'); window.triangleOn(); } function logMouseOut() { formula1.classList.remove('highlightOnWide'); formula1.classList.add('highlightOffWide'); triangleOff(); } const formula2 = document.getElementById('MathJax-Element-13-Frame'); formula2.onmouseover = logMouseOver2; formula2.onmouseout = logMouseOut2; formula2.classList.add('highlightOffWide'); function logMouseOver2() { formula2.classList.remove('highlightOffWide'); formula2.classList.add('highlightOnWide'); window.triangle3On(); } function logMouseOut2() { formula2.classList.remove('highlightOnWide'); formula2.classList.add('highlightOffWide'); triangle3Off(); } const formula3 = document.getElementById('MathJax-Element-14-Frame'); formula3.onmouseover = logMouseOver3; formula3.onmouseout = logMouseOut3; formula3.classList.add('highlightOffWide'); function logMouseOver3() { formula3.classList.remove('highlightOffWide'); formula3.classList.add('highlightOnWide'); window.triangle2On(); } function logMouseOut3() { formula3.classList.remove('highlightOnWide'); formula3.classList.add('highlightOffWide'); triangle2Off(); } const formula4 = document.getElementById('MathJax-Element-15-Frame'); formula4.onmouseover = logMouseOver4; formula4.onmouseout = logMouseOut4; formula4.classList.add('highlightOffNarrow'); function logMouseOver4() { formula4.classList.remove('highlightOffNarrow'); formula4.classList.add('highlightOnNarrow'); window.showH(); } function logMouseOut4() { formula4.classList.remove('highlightOnNarrow'); formula4.classList.add('highlightOffNarrow'); window.hideH(); } const formula5 = document.getElementById('MathJax-Element-16-Frame'); formula5.onmouseover = logMouseOver5; formula5.onmouseout = logMouseOut5; formula5.classList.add('highlightOffNarrow'); function logMouseOver5() { formula5.classList.remove('highlightOffNarrow'); formula5.classList.add('highlightOnNarrow'); window.showR1(); } function logMouseOut5() { formula5.classList.remove('highlightOnNarrow'); formula5.classList.add('highlightOffNarrow'); window.hideR1(); } const formula6 = document.getElementById('MathJax-Element-17-Frame'); formula6.onmouseover = logMouseOver6; formula6.onmouseout = logMouseOut6; formula6.classList.add('highlightOffNarrow'); function logMouseOver6() { formula6.classList.remove('highlightOffNarrow'); formula6.classList.add('highlightOnNarrow'); window.showR2(); } function logMouseOut6() { formula6.classList.remove('highlightOnNarrow'); formula6.classList.add('highlightOffNarrow'); window.hideR2(); } // code for the limit buttons smartdown.setVariable('close', false); smartdown.setVariable('gotozero', false); smartdown.setVariable('reset', false); this.dependOn = ['close', 'gotozero', 'reset']; this.depend = function() { if (env.close == true) { smartdown.setVariable('close',false); window.goClose(); } if (env.gotozero == true) { smartdown.setVariable('gotozero', false); window.goToZero(); } if (env.reset == true) { smartdown.setVariable('reset', false); window.resetSecant(); } }; ``` #### --outlinebox outer2 #### --outlinebox left2 [*h* close to 0](:=close=true) [*h* all the way to 0](:=gotozero=true) [Reset](:=reset=true) You can also drag the orange dot in the leftmost box. [Guided Tour](:=t1=true) #### --outlinebox #### --outlinebox right2 # :::: d1 Let's look at some of these quantities in our secants $h$, $\sin((x + h)^2) - \sin(x^2)$, and $(x + h)^2 - x^2$. [Close](::d1) [Next](:=t2=true) # :::: # :::: d2 Notice that the product of slopes in the right two boxes is equal to the slope in the first box. Try dragging the orange dot in the first box to see different values. [slope2 * slope3](:!slopeProduct) [Back](:=t1=true) [Next](:=t3=true) # :::: # :::: d3 In the right most box, as $h$ goes to $0$, we know how to evaluate this limit. It's the derivative of $k(x) = x^2$. $$\lim_{h \to 0}\frac{(x + h)^2 - x^2}{h} = 2x$$ [Back](:=t2=true) [Next](:=t4=true) # :::: # :::: d4 In the middle box, as $h$ goes to $0$ the secant gets close to a tangent line on the function $g(x) = \sin(x)$, but it's evaluated at $x^2$, not $x$. The derivative of the $\sin$ is the $\cos$ so we have $$\lim_{h \to 0}\frac{\sin((x + h)^2) - \sin(x^2)}{(x + h)^2 - x^2} = \cos(x^2)$$ [Back](:=t3=true) [Next](:=t5=true) # :::: # :::: d5 When $h=0$ the slopes are all are undefined. But this is ok. We're taking the limit so we only care about what happens when $h$ close to $0$. [Back](:=t4=true) [Next](:=t6=true) # :::: # :::: d6 But there is a problem. The value of $(x+h)^2 - x^2$ could be zero in other places then $h=0$. For example, if $x=1$ and $h=-2$ the slope of this secant is undefined. This can be solved with a delta epsilon argument. [See argument](https://en.wikipedia.org/wiki/Chain_rule#First_proof) [Back](:=t5=true) [Next](:=t7=true) # :::: # :::: d7 We can conclude that the derivative of our function $f(x) = \sin(x^2)$ is $$f'(x) = \cos(x^2) \cdot 2x$$ [Back](:=t6=true) [Close](::d7) # :::: #### --outlinebox #### --outlinebox # :::: secant1 This is the standard secant line from the definition of the derivative that we don't know how to solve. # :::: # :::: secant2 This is a secant line on the graph of $g(x) = \sin(x)$, but the change in the $x$ value is different here. Instead of changing by $h$, it changes by $(x + h)^2 - x^2$. # :::: # :::: secant3 This is the secant line on the graph of $k(x) = x^2$. # :::: ```javascript /autoplay smartdown.importCssCode( ` .outer2 { height: 25vh; } .left2 { padding: 10px; font-size: 18px; } .right2 { font-size: 18px; border: 2px solid gray; background-color: #FFFFFF; border-radius: 10px; padding: 20px; } @media (min-width: 800px) { .outer2 { } .left2 { width: 30%; height: 100%; display: inline-block; vertical-align: top; } .right2 { width: 68%; height: 100%; display: inline-block; vertical-align: top; overflow: scroll; } } `); const outer = document.getElementById('outer2'); const left = document.getElementById('left2'); const right = document.getElementById('right2'); outer.classList.remove('decoration-outlinebox'); left.classList.remove('decoration-outlinebox'); right.classList.remove('decoration-outlinebox'); outer.classList.add('outer2'); left.classList.add('left2'); right.classList.add('right2'); ``` ```javascript /autoplay // these are the transitions for the guided tour smartdown.setVariable('t1', false); smartdown.setVariable('t2', false); smartdown.setVariable('t3', false); smartdown.setVariable('t4', false); smartdown.setVariable('t5', false); smartdown.setVariable('t6', false); smartdown.setVariable('t7', false); this.dependOn = ['t1', 't2', 't3', 't4', 't5', 't6', 't7']; this.depend = function() { if (env.t1 == true) { console.log('t1 is true'); smartdown.setVariable('t1',false); smartdown.showDisclosure('d1', '', 'transparent'); smartdown.hideDisclosure('d2', '', 'transparent'); smartdown.hideDisclosure('d3', '', 'transparent'); smartdown.hideDisclosure('d4', '', 'transparent'); smartdown.setVariable('t1',false); } if (env.t2 == true) { smartdown.setVariable('t2', false); smartdown.showDisclosure('d2', '', 'transparent'); smartdown.hideDisclosure('d1', '', 'transparent'); smartdown.hideDisclosure('d3', '', 'transparent'); } if (env.t3 == true) { smartdown.setVariable('t3', false); smartdown.showDisclosure('d3', '', 'transparent'); smartdown.hideDisclosure('d2', '', 'transparent'); smartdown.hideDisclosure('d4', '', 'transparent'); } if (env.t4 == true) { smartdown.setVariable('t4', false); smartdown.showDisclosure('d4', '', 'transparent'); smartdown.hideDisclosure('d3', '', 'transparent'); smartdown.hideDisclosure('d5', '', 'transparent'); } if (env.t5 == true) { smartdown.setVariable('t5', false); smartdown.showDisclosure('d5', '', 'transparent'); smartdown.hideDisclosure('d4', '', 'transparent'); smartdown.hideDisclosure('d6', '', 'transparent'); } if (env.t6 == true) { smartdown.setVariable('t6', false); smartdown.showDisclosure('d6', '', 'transparent'); smartdown.hideDisclosure('d5', '', ''); smartdown.hideDisclosure('d7', '', ''); } if (env.t7 == true) { smartdown.setVariable('t7', false); smartdown.showDisclosure('d7', '', 'transparent'); smartdown.hideDisclosure('d6', '', ''); } }; ```</summary></entry><entry><title type="html">Layouts for Complex Explanations</title><link href="https://wildthinks.org/posts/Layout/" rel="alternate" type="text/html" title="Layouts for Complex Explanations" /><published>2020-03-03T00:00:00-08:00</published><updated>2020-03-03T00:00:00-08:00</updated><id>https://wildthinks.org/posts/Layout</id><content type="html" xml:base="https://wildthinks.org/posts/Layout/">This post is the next iteration in my process to build a strategy for explaining complex mathematical problems, proofs and ideas.  My first attempt can be found [here](/posts/mathExplanations).  The basic idea is to break my explanation down into three parts: the high level ideas, a picture of the model, and symbolic reasoning. The explanation should present all three parts in an integrated way.  It should make sure the main ideas do not get lost in the details and it should help the reader map the symbolic statements to their meaning in the model.  

&lt;!--more--&gt;

My friend [Dan](https://doctorbud.com) gave me the idea of placing each of my three parts of an explanation into a different pane in of a [triptych](https://en.wikipedia.org/wiki/Triptych).  Triptychs are three paneled paintings that were common as altar paintings in the Middle Ages.

![halfwidth](https://upload.wikimedia.org/wikipedia/commons/b/bf/Annunciation_Triptych_%28Merode_Altarpiece%29_MET_DP273206.jpg)

In this second attempt at this explanation I'm going to try a two panel approach, but I'm not done experimenting and I may add another panel yet. I'm going to present the picture of the model in the first panel and combine the high level story with the symbolic reasoning into the second panel.  I'm adding a new **highlight** function that I hope will help readers maintain a mapping between the symbolic formulas and their meaning in the model.  Look for formulas with a gray back ground and hold your mouse over them to see the mapping.


### Finding the Derivative

#### --outlinebox outer1

#### --outlinebox left1

```javascript /playable/autoplay
//smartdown.import=https://cdnjs.cloudflare.com/ajax/libs/jsxgraph/0.99.7/jsxgraphcore.js

smartdown.importCssUrl('https://cdnjs.cloudflare.com/ajax/libs/jsxgraph/0.99.7/jsxgraph.css');
myDiv = this.div;

myDiv.innerHTML = `&lt;div id='box1' class='jxgbox' style='height:500px'&gt;`;


JXG.Options.axis.ticks.majorHeight = 40;
// create the board
board0 = JXG.JSXGraph.initBoard('box1', {boundingbox:[-5,10,5,-3], showCopyright:false, keepaspectratio:false, axis:false});
board0.resizeContainer(myDiv.offsetWidth, myDiv.offsetHeight);

let xaxis = board0.create('axis', [[0, 0], [1,0]], 
      {name:'x', 
      withLabel: true,
      label: {
        fontSize: 20,
        position: 'rt',  // possible values are 'lft', 'rt', 'top', 'bot'
        offset: [-20, 20]   // (in pixels)
      }
      });
let yaxis = board0.create('axis', [[0, 0], [0, 1]], 
      {name:'y', 
      withLabel: true, 
      label: {
        fontSize: 20,
        position: 'rt',  // possible values are 'lft', 'rt', 'top', 'bot'
        offset: [-30, -20]   // (in pixels)
        }
      });   

// parabala and it's derivative
let f = function(x) { return  x*x; };
let df = function(x) { return 2*x; }
let x = board0.create('glider', [2,0, xaxis], {name:'x', size:6});
let fx = board0.create('point', [
  function() { return x.X(); }, 
  function() { return f(x.X()); }], {name:'', color:'#222299', fixed:true});
let graph_f = board0.create('functiongraph', [f,-10,10], {strokeColor:'#999999'});
let graph_df = board0.create('functiongraph', [df,-10,10], {strokeColor:'#44AA44', visible:false});
let dfx = board0.create('point', [
  function() { return x.X(); }, 
  function() { return df(x.X()); }], {name:'', color:'#44AA44', fixed:true, visible:false});

// tangent line section
let tangent = board0.create('line', [
  function() { return f(x.X());},
  function() { return - df(x.X());},
  1], {color:'#222299', visible:true});
let tangentSlopeText = board0.create('text',[
  function() { return x.X() + 0.5; },
  function() { return f(x.X()) + 0.5;},
  function(){ return 'slope = '+ df(x.X()).toFixed(2); }], {fontSize:15, visible:true});


// Secant line section
// the slider point for the secant
let x_h = board0.create('glider', [x.X() + 3, 0, xaxis], {name:'x + h', size:6, color:'green', visible:false} ); 

let highlightFon = function() {
  graph_f.setAttribute({strokeColor:'#33FFFF', strokeWidth:3});
};

let highlightFoff = function() {
  graph_f.setAttribute({strokeColor:'#999999', strokeWidth:1});
};

window.highlightFoff = highlightFoff;
window.highlightFon = highlightFon;

this.sizeChanged = function() {      
  board0.resizeContainer(myDiv.offsetWidth, myDiv.offsetHeight);
};

 
```
#### --outlinebox


#### --outlinebox right1
We want to find the derivative of the function $f(x)=x^2$.  The derivative of a function tells us the **slope** of the tangent line to the function at different points.  But how do we find it?  There is no obvious formula for the slope of the tangent line. 

Drag the red dot to see the slope of the tangent line for different values of $x$.


#### --outlinebox
#### --outlinebox


```javascript /autoplay

smartdown.importCssCode(
`
.outer {
 
}

.left {
  padding-top: 10px; 
}

.right {
  padding-left: 20px;
  padding-right: 20px;
  font-size: 18px;
}

.highlightOn {
  background-color: #33FFFF;
  padding: 10px;
}

.highlightOff {
  background-color: #CCCCCC;
  padding: 10px;
}

@media (min-width: 800px) {
  .outer {
   
  }

  .left {
    width: 50%;
    display: inline-block;
    vertical-align: top;
  }

  .right {
    width: 48%;
    display: inline-block;
    vertical-align: top;
  }
}
`);


const outer = document.getElementById('outer1');
const left = document.getElementById('left1');
const right = document.getElementById('right1');

outer.classList.remove('decoration-outlinebox');
left.classList.remove('decoration-outlinebox');
right.classList.remove('decoration-outlinebox');

outer.classList.add('outer');
left.classList.add('left');
right.classList.add('right');

const formula1 = document.getElementById('MathJax-Element-1-Frame');
formula1.onmouseover = logMouseOver;
formula1.onmouseout = logMouseOut;
formula1.classList.add('highlightOff');

function logMouseOver() {
  formula1.classList.add('highlightOn');
  formula1.classList.remove('highlightOff');
  highlightFon();
}

function logMouseOut() {
  formula1.classList.add('highlightOff');
  formula1.classList.remove('highlightOn');
  highlightFoff();
}

```


### Turning Secants into Tangents
#### --outlinebox outer2

#### --outlinebox left2

```javascript /playable/autoplay
//smartdown.import=https://cdnjs.cloudflare.com/ajax/libs/jsxgraph/0.99.7/jsxgraphcore.js

smartdown.importCssUrl('https://cdnjs.cloudflare.com/ajax/libs/jsxgraph/0.99.7/jsxgraph.css');

const myDiv = this.div;
myDiv.innerHTML = `&lt;div id='box2' class='jxgbox' style='height:500px'&gt;`;

JXG.Options.axis.ticks.majorHeight = 40;
// create the board
board1 = JXG.JSXGraph.initBoard('box2', {boundingbox:[-5,10,5,-3], showCopyright:false, keepaspectratio:false, axis:false});
board1.resizeContainer(myDiv.offsetWidth, myDiv.offsetHeight);

let xaxis = board1.create('axis', [[0, 0], [1,0]], 
      {name:'x', 
      withLabel: true,
      label: {
        fontSize: 20,
        position: 'rt',  // possible values are 'lft', 'rt', 'top', 'bot'
        offset: [-20, 20]   // (in pixels)
      }
      });
let yaxis = board1.create('axis', [[0, 0], [0, 1]], 
      {name:'y', 
      withLabel: true, 
      label: {
        fontSize: 20,
        position: 'rt',  // possible values are 'lft', 'rt', 'top', 'bot'
        offset: [-30, -20]   // (in pixels)
        }
      });   

// parabala and it's derivative
let f = function(x) { return  x*x; };
let df = function(x) { return 2*x; };
let x = board1.create('glider', [1,0, xaxis], {name:'x', fixed:false, size:6});
let fx = board1.create('point', [
  function() { return x.X(); }, 
  function() { return f(x.X()); }], {name:'', color:'#222299', fixed:true});
let graph_f = board1.create('functiongraph', [f,-10,10], {strokeColor:'#999999'});
let graph_df = board1.create('functiongraph', [df,-10,10], {strokeColor:'#44AA44', visible:false});
let dfx = board1.create('point', [
  function() { return x.X(); }, 
  function() { return df(x.X()); }], {name:'', color:'#44AA44', fixed:true, visible:false});


// Secant line section
// the slider point for the secant
let x_h = board1.create('glider', [x.X() + 2, 0, xaxis], {name:'x + h', size:6, color:'green', visible:true} ); 

// sliding point on parabala 
let fx_h = board1.create('point', [
                function() { return x_h.X(); }, 
                function() { return f(x_h.X()); }
          ], {name:'', color:'#222299', fixed: true, size:3, visible:true});

let secant = board1.create('line', [fx, fx_h], {color:'#222299', visible:true});
let secantSlope = function() { 
  if (x.X() == x_h.X()) { return &quot;UNDEFINED: divide by zero&quot;; }
  return ((f(x.X()) - f(x_h.X()))/(x.X() - x_h.X())).toFixed(3).toString(); 
}

let secantSlopeText = board1.create('text',[
  function() { return x.X() + (x_h.X() - x.X())/2 - 1.8; },
  function() { return f(x.X()) + (f(x_h.X()) - f(x.X()))/2;},
  function(){ return 'slope = '+ secantSlope(); }], {fontSize:15, visible:true});

let p = board1.create('point', [ 
  function() { return x_h.X(); }, 
  function() { return f(x.X());}], {visible:false});

let triangle = board1.create('polygon', [fx, fx_h, p], {
  fillColor:'#33FFFF', 
  fillOpacity: 50,
  borders: {strokeColor: 'yellow'}, 
  strokeWidth:3, visible:false});

let rise = board1.create('line', [fx_h, p], {color:'black', strokeWidth:1, straightFirst:false, straightLast:false, dash:2, visible:true});
let run = board1.create('line', [fx, p], {color:'black', strokeWidth:1, straightFirst:false, straightLast:false, dash:2, visible:true});
let riseText = board1.create('text', [
  function() { if (x_h.X() &gt; x.X()) { return x_h.X() + 0.1; } 
         return x_h.X() - 1.5; },
  function() { return (f(x_h.X()) - f(x.X()))/2 + f(x.X()); },
  '(x+h)^2 - x^2'], {fontSize:12, visible:false});

let runText = board1.create('text', [
  function() { return x.X() + (x_h.X() - x.X())/2; },
  function() { return f(x.X()) - 0.1; },
  'h'], {fontSize:12, visible:false});

board1.on('update', function() {
  const xFloor = Math.floor(x.X());
  if ((x.X() - xFloor) &lt; 0.2) {
    x.moveTo([xFloor, 0]);
    return;
  }
  const xCeil = Math.ceil(x.X());
  if ((xCeil - x.X()) &lt; 0.2) {
    x.moveTo([xCeil, 0]);
    return;
  }  
});

let triangleOn = function() {
  triangle.setAttribute({visible:true});
  riseText.setAttribute({visible:true});
  runText.setAttribute({visible:true});
};

let triangleOff = function() {
  triangle.setAttribute({visible:false});
  riseText.setAttribute({visible:false});
  runText.setAttribute({visible:false});
};

window.triangleOff = triangleOff;
window.triangleOn  = triangleOn;

let goClose = function() {
  if (x_h.X() &lt; x.X()) {
    x_h.moveTo([x.X()-0.01, 0],2000);
  }
  else {
    x_h.moveTo([x.X()+0.01, 0],2000);
  }
}

let goToZero = function() {
  x_h.moveTo([x.X(), 0],500);
}

let resetSecant = function() {
  x.moveTo([1,0]);
  x_h.moveTo([3,0]);
};

window.goClose = goClose;
window.goToZero = goToZero;
window.resetSecant = resetSecant;

this.sizeChanged = function() {      
  board1.resizeContainer(myDiv.offsetWidth, myDiv.offsetHeight);
};

 
```
#### --outlinebox

#### --outlinebox right2
We can easily write an expression for the slope of the secant line. 
$$\frac{(x + h)^2 - x^2}{h}$$

You can investigate what happens when $h$ gets very small by dragging the green dot towards the red dot or by using these buttons. [*h* close to 0](:=close=true) [*h* all the way to 0](:=gotozero=true) [Reset](:=reset=true)  You can also drag the red dot.

When $h$ gets close to $0$, the secant line becomes very close to the tangent line.  The slope of this secant line will be very close to the slope of the tangent line. 

Try to guess the slope of the tangent line
when $x=1$ [](:?s1)
when $x=2$ [](:?s2)

If the distance between the points goes all the way to zero, then the slope of the secant is undefined due to division by zero. 


#### --outlinebox
#### --outlinebox


### Taking the Limit
The derivative of a function $f(x)$ is defined as the limit of the slope of the secant as $h$ goes to $0$.  
$$f'(x) = \lim_{h \to 0} \frac{f(x+h) - f(x)}{h}$$
The value of the limit is determined by what happens when $h$ is very near $0$, not what happens when $h=0$.  In this way we avoid the problem of dividing by $0$.

To solve the limit for the function $f(x) = x^2$, we need to do some algebra.
$$
\begin{align}
f'(x) &amp; = \lim_{h \to 0} \frac{(x + h)^2 - x^2}{h} &amp; \newline
&amp; = \lim_{h \to 0} \frac{x^2 + 2hx + h^2 - x^2}{h}  &amp; \textrm{expand $(x+h)^2$} \newline 
&amp; = \lim_{h \to 0} \frac{2hx + h^2}{h} &amp; \textrm{combine like terms}  \newline
&amp; = \lim_{h \to 0} 2x + h &amp; \textrm{cancel $h$ terms}  \newline
\end{align}
$$
All of this assumes that the value $h$ gets infinitely close to $0$ without ever reaching it.
```javascript /autoplay
const outer = document.getElementById('outer2');
const left = document.getElementById('left2');
const right = document.getElementById('right2');

outer.classList.remove('decoration-outlinebox');
left.classList.remove('decoration-outlinebox');
right.classList.remove('decoration-outlinebox');

outer.classList.add('outer');
left.classList.add('left');
right.classList.add('right');

const formula2 = document.getElementById('MathJax-Element-3-Frame');
formula2.onmouseover = logMouseOver3;
formula2.onmouseout = logMouseOut3;
formula2.classList.add('highlightOff');

function logMouseOver3() {
  formula2.classList.remove('highlightOff');
  formula2.classList.add('highlightOn');
  window.triangleOn();
}

function logMouseOut3() {
  formula2.classList.remove('highlightOn');
  formula2.classList.add('highlightOff');
  triangleOff();
}

smartdown.setVariable('close', false);
smartdown.setVariable('gotozero', false);
smartdown.setVariable('reset', false);

this.dependOn = ['close', 'gotozero', 'reset'];
this.depend = function() {
  if (env.close == true) {
    smartdown.setVariable('close',false);
    window.goClose();
  }
  if (env.gotozero == true) {
    smartdown.setVariable('gotozero', false);
    window.goToZero();
  }
  if (env.reset == true) {
    smartdown.setVariable('reset', false);
    window.resetSecant();
    }
};

```

```javascript /autoplay
smartdown.setVariable('s1', '');
this.dependOn = ['s1'];
this.depend = function() {
  if (env.s1 == '2') {
    smartdown.showDisclosure('correct','','bottomright,transparent,shadow'); 
    setTimeout(function () {
         smartdown.hideDisclosure('correct','','bottomright'); 
    }, 3000);
  }
};
```

```javascript /autoplay
smartdown.setVariable('s2', '');
this.dependOn = ['s2'];
this.depend = function() {
  if (env.s2 == '4') {
    smartdown.showDisclosure('correct','','bottomright,transparent,shadow'); 
    setTimeout(function () {
         smartdown.hideDisclosure('correct','','bottomright'); 
    }, 3000);
  }

};
```
#### --outlinebox outer3

#### --outlinebox left3

```javascript /playable/autoplay
//smartdown.import=https://cdnjs.cloudflare.com/ajax/libs/jsxgraph/0.99.7/jsxgraphcore.js

smartdown.importCssUrl('https://cdnjs.cloudflare.com/ajax/libs/jsxgraph/0.99.7/jsxgraph.css');
myDiv = this.div;

myDiv.innerHTML = `&lt;div id='box3' class='jxgbox' style='height:500px'&gt;`;


JXG.Options.axis.ticks.majorHeight = 40;
// create the board
board2 = JXG.JSXGraph.initBoard('box3', {boundingbox:[-5,10,5,-3], showCopyright:false, keepaspectratio:false, axis:false});
board2.resizeContainer(myDiv.offsetWidth, myDiv.offsetHeight);

let xaxis = board2.create('axis', [[0, 0], [1,0]], 
      {name:'x', 
      withLabel: true,
      label: {
        fontSize: 20,
        position: 'rt',  // possible values are 'lft', 'rt', 'top', 'bot'
        offset: [-20, 20]   // (in pixels)
      }
      });
let yaxis = board2.create('axis', [[0, 0], [0, 1]], 
      {name:'y', 
      withLabel: true, 
      label: {
        fontSize: 20,
        position: 'rt',  // possible values are 'lft', 'rt', 'top', 'bot'
        offset: [-30, -20]   // (in pixels)
        }
      });   

// parabala and it's derivative
let f = function(x) { return  x*x; };
let df = function(x) { return 2*x; }
let x = board2.create('glider', [2,0, xaxis], {name:'x', size:6});
let fx = board2.create('point', [
  function() { return x.X(); }, 
  function() { return f(x.X()); }], {name:'', color:'#222299', fixed:true});
let graph_f = board2.create('functiongraph', [f,-10,10], {strokeColor:'#999999'});
let graph_df = board2.create('functiongraph', [df,-10,10], {strokeColor:'green', visible:true});
let dfx = board2.create('point', [
  function() { return x.X(); }, 
  function() { return df(x.X()); }], {name:'', color:'green', fixed:true, visible:true});
let dfText = board2.create('text',[
  function() { return x.X() - 1.4; },
  function() { return df(x.X()) + 0.3;},
  function(){ return '('+ x.X().toFixed(2) + ',' + df(x.X()).toFixed(2) + ')'; }], {fontSize:15, visible:true});

// tangent line section
let tangent = board2.create('line', [
  function() { return f(x.X());},
  function() { return - df(x.X());},
  1], {color:'#222299', visible:true});
let tangentSlopeText = board2.create('text',[
  function() { return x.X() + 0.3; },
  function() { return f(x.X()) + 0.3;},
  function(){ return 'slope = '+ df(x.X()).toFixed(2); }], {fontSize:15, visible:true});


// Secant line section
// the slider point for the secant
let x_h = board2.create('glider', [x.X() + 3, 0, xaxis], {name:'x + h', size:6, color:'green', visible:false} ); 

let highlightDFon = function() {
  graph_df.setAttribute({strokeColor:'#33FFFF', strokeWidth:3});
};

let highlightDFoff = function() {
  graph_df.setAttribute({strokeColor:'green', strokeWidth:1});
};

window.highlightDFon = highlightDFon;
window.highlightDFoff = highlightDFoff;

this.sizeChanged = function() {      
  board2.resizeContainer(myDiv.offsetWidth, myDiv.offsetHeight);
};

 
```
#### --outlinebox


#### --outlinebox right3
Finally, we note that for very small values of $h$, the value of 
$$\lim_{h \to 0} 2x + h$$ becomes $2x$.  
So the derivative of $f(x) = x^2$ is 
$$f'(x) = 2x$$

Drag the red dot to verify that the function $f'(x) = 2x$ gives the slope of the tangent line.

When the derivative $f'(x)$ is positive the function $f(x)$ [[](:!increasing)](::pulldown1/tooltip). When the derivative is negative the function [[](:!decreasing)](::pulldown2/tooltip). When the derivative is zero the function [[](:!minimum)](::pulldown3/tooltip).
#### --outlinebox
#### --outlinebox


# :::: pulldown1
[](:Xa1) is increasing
[](:Xa2) is decreasing
[](:Xa3) has a minimum
# ::::

# :::: pulldown2
[](:Xa4) is increasing
[](:Xa5) is decreasing
[](:Xa6) has a minimum
# ::::

# :::: pulldown3
[](:Xa7) is increasing
[](:Xa8) is decreasing
[](:Xa9) has a minimum
# ::::


```javascript /autoplay
smartdown.setVariable('a1', false);
smartdown.setVariable('a2', false);
smartdown.setVariable('a3', false);
smartdown.setVariable('increasing', '________');

this.dependOn = ['a1', 'a2', 'a3'];

this.depend = function() {
  if (env.a1 == true &amp;&amp; env.a2 == false &amp;&amp; env.a3 == false) {
      smartdown.setVariable('increasing', 'is increasing');
      smartdown.showDisclosure('correct','','bottomright,transparent,shadow'); 
      setTimeout(function () {
           smartdown.hideDisclosure('correct','','bottomright'); 
      }, 3000);
    } 
  };
```


```javascript /autoplay
smartdown.setVariable('a4', false);
smartdown.setVariable('a5', false);
smartdown.setVariable('a6', false);
smartdown.setVariable('decreasing', '________');

this.dependOn = ['a4', 'a5', 'a6'];

this.depend = function() {
  if (env.a4 == false &amp;&amp; env.a5 == true &amp;&amp; env.a6 == false) {
      smartdown.setVariable('decreasing', 'is decreasing');
      smartdown.showDisclosure('correct','','bottomright,transparent,shadow'); 
      setTimeout(function () {
           smartdown.hideDisclosure('correct','','bottomright'); 
      }, 3000);
    } 
  };
```


```javascript /autoplay
smartdown.setVariable('a7', false);
smartdown.setVariable('a8', false);
smartdown.setVariable('a9', false);
smartdown.setVariable('minimum', '________');

this.dependOn = ['a7', 'a8', 'a9'];

this.depend = function() {
  if (env.a7 == false &amp;&amp; env.a8 == false &amp;&amp; env.a9 == true) {
      smartdown.setVariable('minimum', 'has a minimum');
      smartdown.showDisclosure('correct','','bottomright,transparent,shadow'); 
      setTimeout(function () {
           smartdown.hideDisclosure('correct','','bottomright'); 
      }, 3000);
    } 
  };
```


```javascript /autoplay

const outer = document.getElementById('outer3');
const left = document.getElementById('left3');
const right = document.getElementById('right3');

outer.classList.remove('decoration-outlinebox');
left.classList.remove('decoration-outlinebox');
right.classList.remove('decoration-outlinebox');

outer.classList.add('outer');
left.classList.add('left');
right.classList.add('right');

const formula3 = document.getElementById('MathJax-Element-25-Frame');
formula3.onmouseover = logMouseOver4;
formula3.onmouseout = logMouseOut4;
formula3.classList.add('highlightOff');

function logMouseOver4() {
  formula3.classList.remove('highlightOff');
  formula3.classList.add('highlightOn');
  window.highlightDFon();
}

function logMouseOut4() {
  formula3.classList.remove('highlightOn');
  formula3.classList.add('highlightOff');
  window.highlightDFoff();
}

```
# :::: correct
# --colorbox right
correct! :grinning:
# --colorbox
# ::::</content><author><name>Heidi Dixon</name></author><summary type="html">This post is the next iteration in my process to build a strategy for explaining complex mathematical problems, proofs and ideas. My first attempt can be found [here](/posts/mathExplanations). The basic idea is to break my explanation down into three parts: the high level ideas, a picture of the model, and symbolic reasoning. The explanation should present all three parts in an integrated way. It should make sure the main ideas do not get lost in the details and it should help the reader map the symbolic statements to their meaning in the model.</summary></entry><entry><title type="html">Managing Complexity in Mathematical Explanations</title><link href="https://wildthinks.org/posts/mathExplanations/" rel="alternate" type="text/html" title="Managing Complexity in Mathematical Explanations" /><published>2020-02-19T00:00:00-08:00</published><updated>2020-02-19T00:00:00-08:00</updated><id>https://wildthinks.org/posts/mathExplanations</id><content type="html" xml:base="https://wildthinks.org/posts/mathExplanations/">For me, a mathematical explanation has three parts: the high level ideas, a picture of the model, and symbolic reasoning. Following the symbolic reasoning in proofs and explanations requires effort and focus. When we are done, we may believe the derived statement is true, but we've forgotten what it actually means in relation to the model.  I'm trying to develop a strategy for explaining complex mathematical ideas that allows folks to maintain the mapping between the notational statements and their meaning along the way.


All three parts of an explanation are necessary.  The high level ideas tell us what we are doing and why we are doing it.  This is the story we are telling.  It's also the things we most want the reader to remember. The picture of the model is a description of the actual problem.  It's where the real understanding happens. The symbolic reasoning is where we write statements with mathematical notation and do inference and reasoning with those statements.  This could include algebra or logical proof steps.  


Currently, I write all my explanations using [smartdown](https://smartdown.site/#gallery/Home.md). For those of you not familiar with smartdown, it's an easy way for people who aren't front end web developers to write interactive web content.  It's free and easy to use.  Everything on this blog is written in smartdown. I'm trying to find a methodology for my process within the tools supplied by smartdown.  However, it's likely that this exploration will lead to the development of new smartdown tools. Explaining complex topics with challenging notation is not unique to the field of mathematics so lots of folks could benefit from tools for this kind of thing.  We begin with an example problem.  
# --outlinebox ob1
**Problem:**
Find the derivative of the function $f(x) = x^2$ using the definition of the derivative.
# --outlinebox

First we'll look at the three pieces of the explanation separately. 
### High Level Ideas
This explanation has three anchor ideas.

1. **Find the Derivative** -- We want to find the derivative for the function $f(x)=x^2$.
2. **Derivatives are Slopes** -- We want the reader to remember that derivatives are a description of slopes. The definition of the derivative begins with a generalized expression for the **slope** of a secant line and represents the slope of the tangent line.  
3. **Use a limit to turn a secant into a tangent** -- To make the definition work, we need to take the limit as the secant line gets very, very tiny and becomes a tangent.

### Symbolic Reasoning
Here's the symbolic reasoning we need to cover.  Most of it is algebra.
$$
\begin{align}
f'(x) &amp; =  \lim_{h \to 0}\frac{f(x+h) - f(x)}{h} \\
&amp; =  \lim_{h \to 0}\frac{(x + h)^2 - x^2}{h} \\
&amp; =   \lim_{h \to 0} \frac{x^2 + 2hx + h^2 - x^2}{h} \\
&amp; =   \lim_{h \to 0} \frac{2hx + h^2}{h} \\
&amp; =   \lim_{h \to 0} 2x + h \\
&amp; =   2x
\end{align}
$$

Just looking at it all alone without words or pictures drives home how disorienting the symbolic reasoning can  be even if it's clear and well written.

### Picture of the Model
I have two related pictures of the model I want to present.  The first is a picture showing a tangent line to the function, and the second showing a secant line.  The two pictures have many of the same components, so combining them into one picture would make the explanation easier to follow. 


#### Picture 1: Tangent Line
You can drag the red dot left and right to see different tangent lines.
```javascript /autoplay
//smartdown.import=https://cdnjs.cloudflare.com/ajax/libs/jsxgraph/0.99.7/jsxgraphcore.js

smartdown.importCssUrl('https://cdnjs.cloudflare.com/ajax/libs/jsxgraph/0.99.7/jsxgraph.css');

const myDiv = this.div;
myDiv.style.width = '100%';
myDiv.style.height = '100%';
myDiv.style.margin = 'auto';
myDiv.innerHTML = `&lt;div id='box2' class='jxgbox' style='height:500px;'&gt;`;

JXG.Options.axis.ticks.majorHeight = 40;
// create the board
board0 = JXG.JSXGraph.initBoard('box2', {boundingbox:[-5,10,20,-3], showCopyright:false, keepaspectratio:false, axis:false});

let xaxis = board0.create('axis', [[0, 0], [1,0]], 
      {name:'x', 
      withLabel: true,
      label: {
        fontSize: 20,
        position: 'rt',  // possible values are 'lft', 'rt', 'top', 'bot'
        offset: [-20, 20]   // (in pixels)
      }
      });
let yaxis = board0.create('axis', [[0, 0], [0, 1]], 
      {name:'y', 
      withLabel: true, 
      label: {
        fontSize: 20,
        position: 'rt',  // possible values are 'lft', 'rt', 'top', 'bot'
        offset: [-30, -20]   // (in pixels)
        }
      });   

// parabala and it's derivative
let f = function(x) { return  x*x; };
let df = function(x) { return 2 * x; }

let x = board0.create('glider', [1,0, xaxis], {name:'x', size:6});
let fx = board0.create('point', [
	function() { return x.X(); }, 
	function() { return f(x.X()); }], {name:'', color:'blue'})
let graph_f = board0.create('functiongraph', [f,-10,10], {strokeColor:'#999999'});
// let graph_df = board0.create('functiongraph', [df,-10,10],{strokeColor: '#11AA66', visible:true});
let tangent = board0.create('line', [
	function() { return f(x.X());},
	function() { return - df(x.X());},
	1]);

// print the slope of the secant line
let slopeText = board0.create('text',[
	function() { return x.X() + 0.5; },
	function() { return f(x.X()) + 0.5;},
	function(){ return 'slope = '+ df(x.X()).toFixed(2); }], {fontSize:15});


```
#### Picture 2: Secant Line
In this picture you can drag the green and red dots to see different secant lines.

```javascript /autoplay
//smartdown.import=https://cdnjs.cloudflare.com/ajax/libs/jsxgraph/0.99.7/jsxgraphcore.js

smartdown.importCssUrl('https://cdnjs.cloudflare.com/ajax/libs/jsxgraph/0.99.7/jsxgraph.css');

const myDiv = this.div;
myDiv.style.width = '100%';
myDiv.style.height = '100%';
myDiv.style.margin = 'auto';
myDiv.innerHTML = `&lt;div id='box3' class='jxgbox' style='height:500px;'&gt;`;

JXG.Options.axis.ticks.majorHeight = 40;
// create the board
board0 = JXG.JSXGraph.initBoard('box3', {boundingbox:[-5,10,20,-3], showCopyright:false, keepaspectratio:false, axis:false});

board0.resizeContainer(myDiv.offsetWidth, myDiv.offsetHeight);

let xaxis = board0.create('axis', [[0, 0], [1,0]], 
      {name:'x', 
      withLabel: true,
      label: {
        fontSize: 20,
        position: 'rt',  // possible values are 'lft', 'rt', 'top', 'bot'
        offset: [-20, 20]   // (in pixels)
      }
      });
let yaxis = board0.create('axis', [[0, 0], [0, 1]], 
      {name:'y', 
      withLabel: true, 
      label: {
        fontSize: 20,
        position: 'rt',  // possible values are 'lft', 'rt', 'top', 'bot'
        offset: [-30, -20]   // (in pixels)
        }
      });   

// parabala and it's derivative
let f = function(x) { return  x*x; };
let df = function(x) { return 2 * x; }
let graph_f = board0.create('functiongraph', [f,-10,10], {strokeColor:'#999999'});
//let graph_df = board0.create('functiongraph', [df,-10,10],{strokeColor: '#11AA66', visible:true});

// point x on axis we want to get derivative value
let x = board0.create('glider', [1,0, xaxis], {name:'x', size:6});
let fx = board0.create('point', [ 
	function() { return x.X(); },
	function() { return f(x.X()); }], {name:'', color:'blue', fixed:true});

// the slider point for the secant
let x_h = board0.create('glider', [x.X() + 1, 0, xaxis], {name:'x + h', size:6, color:'green'} ); 

// sliding point on parabala 
let fx_h = board0.create('point', [
                function() { return x_h.X(); }, 
                function() { return f(x_h.X()); }
          ], {name:'', color: 'blue', fixed: true, size:3});

// secant line
let secant = board0.create('line', [fx, fx_h], {strokeColor:'blue'});
let secantSlope = function() { 
	if (x.X() == x_h.X()) { return &quot;UNDEFINED: divide by zero&quot;; }
	return ((f(x.X()) - f(x_h.X()))/(x.X() - x_h.X())).toFixed(3).toString(); 
}

let secantSlopeText = board0.create('text',[
	function() { return x.X() + (x_h.X() - x.X())/2 - 1.8; },
	function() { return f(x.X()) + (f(x_h.X()) - f(x.X()))/2;},
	function(){ return 'slope = '+ secantSlope(); }], {fontSize:15, visible:false});


let p = board0.create('point', [ 
	function() { return x_h.X(); }, 
	function() { return f(x.X());}], {visible:false});

let rise = board0.create('line', [fx_h, p], {color:'black', strokeWidth:1, straightFirst:false, straightLast:false, dash:2});
let run = board0.create('line', [fx, p], {color:'black', strokeWidth:1, straightFirst:false, straightLast:false, dash:2});
let riseText = board0.create('text', [
	function() { if (x_h.X() &gt; x.X()) { return x_h.X() + 0.1; } 
				 return x_h.X() - 1.5; },
	function() { return (f(x_h.X()) - f(x.X()))/2 + f(x.X()); },
	'(x+h)^2 - x^2'], {fontSize:12});

let runText = board0.create('text', [
	function() { return x.X() + (x_h.X() - x.X())/2; },
	function() { return f(x.X()) - 0.3; },
	'h'], {fontSize:12});

this.sizeChanged = function() {      
  board0.resizeContainer(myDiv.offsetWidth, myDiv.offsetHeight);
};

 
```

### Putting it all Together
Here's my first prototype that attempts to maintain the mapping between the symbolic reasoning and the model. I'm using smartdown's [disclosables](https://smartdown.site/#gallery/Disclosables.md) to place the main ideas and symbolic reasoning next to the picture of the model.  I don't have very much control over the positioning of the disclosables so I've made them draggable.  There's a little black dot on each pop up that allows you to position them. It's also difficult to control the width of the pop ups.  A two column format might be a better solution with one column holding the picture and the second containing a slide show of the main anchor points.  Will talk to [Dan Keith](https://doctorbud.com) (the smartdown guy) about how to make this better.

This explanation is intended for students who are taking calculus and are familiar with calculus notation and ideas so many of the terms and notations aren't defined.  However, I think a non calculus student could still get the idea of what's happening here even if some of the notation and terms are unfamiliar.  

[start explanation](:=start=true) [derivative](:=transition4=true)
```javascript /autoplay
//smartdown.import=https://cdnjs.cloudflare.com/ajax/libs/jsxgraph/0.99.7/jsxgraphcore.js

smartdown.importCssUrl('https://cdnjs.cloudflare.com/ajax/libs/jsxgraph/0.99.7/jsxgraph.css');

const myDiv = this.div;
myDiv.style.width = '100%';
myDiv.style.height = '100%';
myDiv.style.margin = 'auto';
myDiv.innerHTML = `&lt;div id='box1' class='jxgbox' style='height:500px;'&gt;`;

JXG.Options.axis.ticks.majorHeight = 40;
// create the board
board0 = JXG.JSXGraph.initBoard('box1', {boundingbox:[-5,10,20,-3], showCopyright:false, keepaspectratio:false, axis:false});
board0.resizeContainer(myDiv.offsetWidth, myDiv.offsetHeight);

let xaxis = board0.create('axis', [[0, 0], [1,0]], 
      {name:'x', 
      withLabel: true,
      label: {
        fontSize: 20,
        position: 'rt',  // possible values are 'lft', 'rt', 'top', 'bot'
        offset: [-20, 20]   // (in pixels)
      }
      });
let yaxis = board0.create('axis', [[0, 0], [0, 1]], 
      {name:'y', 
      withLabel: true, 
      label: {
        fontSize: 20,
        position: 'rt',  // possible values are 'lft', 'rt', 'top', 'bot'
        offset: [-30, -20]   // (in pixels)
        }
      });   

// parabala and it's derivative
let f = function(x) { return  x*x; };
let df = function(x) { return 2 * x; }
let x = board0.create('glider', [1,0, xaxis], {name:'x', size:6});
let fx = board0.create('point', [
	function() { return x.X(); }, 
	function() { return f(x.X()); }], {name:'', color:'blue', fixed:true});
let graph_f = board0.create('functiongraph', [f,-10,10], {strokeColor:'#999999'});
let graph_df = board0.create('functiongraph', [df,-10,10], {strokeColor:'#44AA44', visible:false});
let dfx = board0.create('point', [
	function() { return x.X(); }, 
	function() { return df(x.X()); }], {name:'', color:'#44AA44', fixed:true, visible:false});

// tangent line section
let tangent = board0.create('line', [
	function() { return f(x.X());},
	function() { return - df(x.X());},
	1], {visible:true});
let tangentSlopeText = board0.create('text',[
	function() { return x.X() + 0.5; },
	function() { return f(x.X()) + 0.5;},
	function(){ return 'slope = '+ df(x.X()).toFixed(2); }], {fontSize:15, visible:true});


// Secant line section
// the slider point for the secant
let x_h = board0.create('glider', [x.X() + 1, 0, xaxis], {name:'x + h', size:6, color:'green', visible:false} ); 

// sliding point on parabala 
let fx_h = board0.create('point', [
                function() { return x_h.X(); }, 
                function() { return f(x_h.X()); }
          ], {name:'', color: 'blue', fixed: true, size:3, visible:false});

let secant = board0.create('line', [fx, fx_h], {strokeColor:'blue', visible:false});
let secantSlope = function() { 
	if (x.X() == x_h.X()) { return &quot;UNDEFINED: divide by zero&quot;; }
	return ((f(x.X()) - f(x_h.X()))/(x.X() - x_h.X())).toFixed(3).toString(); 
}

let secantSlopeText = board0.create('text',[
	function() { return x.X() + (x_h.X() - x.X())/2 - 1.8; },
	function() { return f(x.X()) + (f(x_h.X()) - f(x.X()))/2;},
	function(){ return 'slope = '+ secantSlope(); }], {fontSize:15, visible:false});

let p = board0.create('point', [ 
	function() { return x_h.X(); }, 
	function() { return f(x.X());}], {visible:false});

let rise = board0.create('line', [fx_h, p], {color:'black', strokeWidth:1, straightFirst:false, straightLast:false, dash:2, visible:false});
let run = board0.create('line', [fx, p], {color:'black', strokeWidth:1, straightFirst:false, straightLast:false, dash:2, visible:false});
let riseText = board0.create('text', [
	function() { if (x_h.X() &gt; x.X()) { return x_h.X() + 0.1; } 
				 return x_h.X() - 1.5; },
	function() { return (f(x_h.X()) - f(x.X()))/2 + f(x.X()); },
	'(x+h)^2 - x^2'], {fontSize:12, visible:false});

let runText = board0.create('text', [
	function() { return x.X() + (x_h.X() - x.X())/2; },
	function() { return f(x.X()) - 0.3; },
	'h'], {fontSize:12, visible:false});


// board0.on('update', function() {
// 	//smartdown.setVariable('hvalue', (x_h.X() - x.X()).toFixed(3));
// });

let showTangent = function() {
	tangent.setAttribute({visible:true});
	tangentSlopeText.setAttribute({visible:true});
};

let hideTangent = function() {
	tangent.setAttribute({visible:false});
	tangentSlopeText.setAttribute({visible:false});
};

let showSecant = function() {
	x_h.setAttribute({visible:true});
	fx_h.setAttribute({visible:true});
	secant.setAttribute({visible:true});
	secantSlopeText.setAttribute({visible:true});
	rise.setAttribute({visible:true});
	run.setAttribute({visible:true});
	riseText.setAttribute({visible:true});
	runText.setAttribute({visible:true});
};

let hideSecant = function() {
	x_h.setAttribute({visible:false});
	fx_h.setAttribute({visible:false});
	secant.setAttribute({visible:false});
	secantSlopeText.setAttribute({visible:false});
	rise.setAttribute({visible:false});
	run.setAttribute({visible:false});
	riseText.setAttribute({visible:false});
	runText.setAttribute({visible:false});
};

let derivativeOn = false;
let showDerivative = function() {
	graph_df.setAttribute({visible:true});
	dfx.setAttribute({visible:true});
};

let hideDerivative = function() {
	graph_df.setAttribute({visible:false});
	dfx.setAttribute({visible:false});
};


this.sizeChanged = function() {      
  board0.resizeContainer(myDiv.offsetWidth, myDiv.offsetHeight);
};

smartdown.setVariable('start', false);
smartdown.setVariable('transition1', false);
smartdown.setVariable('transition2', false);
smartdown.setVariable('transition3', false);
smartdown.setVariable('transition4', false);
smartdown.setVariable('hValue', 1);

board0.on('update', function() {
	smartdown.setVariable('hValue', (x_h.X() - x.X()).toFixed(3));
});

this.dependOn = ['start', 'transition1', 'transition2', 'transition3', 'transition4'];
this.depend = function() {
	if (env.start == true) {
		smartdown.showDisclosure('mi1', '', 'bottomright,shadow,draggable');
		smartdown.hideDisclosure('mi2', '', 'bottomright,shadow,draggable');
		smartdown.hideDisclosure('mi3', '', 'bottomright,shadow,draggable');
		hideSecant();
		showTangent();
		smartdown.setVariable('start',false);
	}
	// board0.suspendUpdate();
	if (env.transition1 == true) {
		hideSecant();
		showTangent();
		smartdown.setVariable('transition1', false);
		smartdown.showDisclosure('mi1', '', 'bottomright,shadow,draggable');
		smartdown.hideDisclosure('mi2', '', 'bottomright,shadow,draggable');	
	}
	if (env.transition2 == true) {
		x.moveTo([1,0]);
		showSecant();
		hideTangent();
		smartdown.setVariable('transition2', false);
		smartdown.showDisclosure('mi2', '', 'bottomright,shadow,draggable');
		smartdown.hideDisclosure('mi1', '', 'bottomright,shadow,draggable');
		smartdown.hideDisclosure('mi3', '', 'bottomright,shadow,draggable');
	}
	if (env.transition3 == true) {
		smartdown.setVariable('transition3', false);
		smartdown.showDisclosure('mi3', '', 'bottomright,shadow,draggable');
		smartdown.hideDisclosure('mi2', '', 'bottomright,shadow,draggable');
	}
	if (env.transition4 == true) {
		if (derivativeOn) { hideDerivative(); }
		else { showDerivative(); }
		derivativeOn = !derivativeOn;
		smartdown.setVariable('transition4', false);
	}
	// board0.unsuspendUpdate();
};
 
```
### Conclusion

I plan to show this to Dan this week to give him a sense of what I want to achieve with these types of explanations.  The main goal is to keep all three parts of the explanation integrated so the reader never loses track of the big picture and the meaning of notational statements.  I hope to build and post an improved prototype soon.  Then I can easily integrate this approach into all my explanations.


# :::: mi1
### Finding the Derivative
We want to find a function that tells us the **slope** 
of the tangent line for the function $f(x)=x^2$.
Drag the red dot to see the slope of the tangent line.
[Next](:=transition2=true)
# ::::

# :::: mi2
### Derivatives are Slopes
The derivative definition starts with the **slope** of a secant line. 
See if you can understand why this expression describes the slope by 
looking at the picture.
$$\frac{(x + h)^2 - x^2}{h}$$
[Do some algebra](::algebra/button,transparent)
# :::: algebra
$$
\begin{align}
\frac{x^2 + 2hx + h^2 - x^2}{h} &amp;  &amp; \textrm{combine like terms}  \newline
\frac{2hx + h^2}{h}  &amp;  &amp; \textrm{cancel $h$ terms}   \newline
2x + h &amp;
\end{align}
$$
The expression $2x + h$ represents the **slope** of the secant line 
for all values of $x$ and $h$.
# ::::
[Back](:=transition1=true) [Next](:=transition3=true)
# ::::

# :::: mi3
#### Turn a Secant into a Tangent
We can use a **limit** to turn a secant into a tangent.
If we drag the green dot $x+h$  towards the red $x$ dot 
- the value of $h$ gets very small. **h** = [](:!hValue) 
- the secant gets closer to the tangent 
- the slope of the secant $2x + h$ gets close to $2x$.

We write this as
$$f'(x) = \lim_{h \to 0} 2x + h = 2x$$
The derivative of $f(x) = x^2$ is the function
$$f'(x) = 2x$$
[Back](:=transition2=true) [Close](::mi3)
# ::::

# :::: pulldown1
[](:Xa1) price of tea in China
[](:Xa2) 10 meters
[](:Xa3) slope of the secant line
# ::::

```javascript/autoplay
smartdown.setVariable('a1', false);
smartdown.setVariable('a2', false);
smartdown.setVariable('a3', false);
smartdown.setVariable('secantSlope', '________');

this.dependOn = ['a1', 'a2', 'a3'];

this.depend = function() {
  if (env.a1 == false &amp;&amp; env.a2 == false &amp;&amp; env.a3 == true) {
      smartdown.setVariable('secantSlope', 'slope of the secant line');
      smartdown.showDisclosure('correct','','bottomright,transparent,shadow'); 
      setTimeout(function () {
           smartdown.hideDisclosure('correct','','bottomright'); 
      }, 3000);
    } 
  };
```

# :::: correct
# --colorbox right
correct! :grinning:
# --colorbox
# ::::</content><author><name>Heidi Dixon</name></author><summary type="html">For me, a mathematical explanation has three parts: the high level ideas, a picture of the model, and symbolic reasoning. Following the symbolic reasoning in proofs and explanations requires effort and focus. When we are done, we may believe the derived statement is true, but we've forgotten what it actually means in relation to the model. I'm trying to develop a strategy for explaining complex mathematical ideas that allows folks to maintain the mapping between the notational statements and their meaning along the way. All three parts of an explanation are necessary. The high level ideas tell us what we are doing and why we are doing it. This is the story we are telling. It's also the things we most want the reader to remember. The picture of the model is a description of the actual problem. It's where the real understanding happens. The symbolic reasoning is where we write statements with mathematical notation and do inference and reasoning with those statements. This could include algebra or logical proof steps. Currently, I write all my explanations using [smartdown](https://smartdown.site/#gallery/Home.md). For those of you not familiar with smartdown, it's an easy way for people who aren't front end web developers to write interactive web content. It's free and easy to use. Everything on this blog is written in smartdown. I'm trying to find a methodology for my process within the tools supplied by smartdown. However, it's likely that this exploration will lead to the development of new smartdown tools. Explaining complex topics with challenging notation is not unique to the field of mathematics so lots of folks could benefit from tools for this kind of thing. We begin with an example problem. # --outlinebox ob1 **Problem:** Find the derivative of the function $f(x) = x^2$ using the definition of the derivative. # --outlinebox First we'll look at the three pieces of the explanation separately. ### High Level Ideas This explanation has three anchor ideas. 1. **Find the Derivative** -- We want to find the derivative for the function $f(x)=x^2$. 2. **Derivatives are Slopes** -- We want the reader to remember that derivatives are a description of slopes. The definition of the derivative begins with a generalized expression for the **slope** of a secant line and represents the slope of the tangent line. 3. **Use a limit to turn a secant into a tangent** -- To make the definition work, we need to take the limit as the secant line gets very, very tiny and becomes a tangent. ### Symbolic Reasoning Here's the symbolic reasoning we need to cover. Most of it is algebra. $$ \begin{align} f'(x) &amp; = \lim_{h \to 0}\frac{f(x+h) - f(x)}{h} \\ &amp; = \lim_{h \to 0}\frac{(x + h)^2 - x^2}{h} \\ &amp; = \lim_{h \to 0} \frac{x^2 + 2hx + h^2 - x^2}{h} \\ &amp; = \lim_{h \to 0} \frac{2hx + h^2}{h} \\ &amp; = \lim_{h \to 0} 2x + h \\ &amp; = 2x \end{align} $$ Just looking at it all alone without words or pictures drives home how disorienting the symbolic reasoning can be even if it's clear and well written. ### Picture of the Model I have two related pictures of the model I want to present. The first is a picture showing a tangent line to the function, and the second showing a secant line. The two pictures have many of the same components, so combining them into one picture would make the explanation easier to follow. #### Picture 1: Tangent Line You can drag the red dot left and right to see different tangent lines. ```javascript /autoplay //smartdown.import=https://cdnjs.cloudflare.com/ajax/libs/jsxgraph/0.99.7/jsxgraphcore.js smartdown.importCssUrl('https://cdnjs.cloudflare.com/ajax/libs/jsxgraph/0.99.7/jsxgraph.css'); const myDiv = this.div; myDiv.style.width = '100%'; myDiv.style.height = '100%'; myDiv.style.margin = 'auto'; myDiv.innerHTML = ``; JXG.Options.axis.ticks.majorHeight = 40; // create the board board0 = JXG.JSXGraph.initBoard('box2', {boundingbox:[-5,10,20,-3], showCopyright:false, keepaspectratio:false, axis:false}); let xaxis = board0.create('axis', [[0, 0], [1,0]], {name:'x', withLabel: true, label: { fontSize: 20, position: 'rt', // possible values are 'lft', 'rt', 'top', 'bot' offset: [-20, 20] // (in pixels) } }); let yaxis = board0.create('axis', [[0, 0], [0, 1]], {name:'y', withLabel: true, label: { fontSize: 20, position: 'rt', // possible values are 'lft', 'rt', 'top', 'bot' offset: [-30, -20] // (in pixels) } }); // parabala and it's derivative let f = function(x) { return x*x; }; let df = function(x) { return 2 * x; } let x = board0.create('glider', [1,0, xaxis], {name:'x', size:6}); let fx = board0.create('point', [ function() { return x.X(); }, function() { return f(x.X()); }], {name:'', color:'blue'}) let graph_f = board0.create('functiongraph', [f,-10,10], {strokeColor:'#999999'}); // let graph_df = board0.create('functiongraph', [df,-10,10],{strokeColor: '#11AA66', visible:true}); let tangent = board0.create('line', [ function() { return f(x.X());}, function() { return - df(x.X());}, 1]); // print the slope of the secant line let slopeText = board0.create('text',[ function() { return x.X() + 0.5; }, function() { return f(x.X()) + 0.5;}, function(){ return 'slope = '+ df(x.X()).toFixed(2); }], {fontSize:15}); ``` #### Picture 2: Secant Line In this picture you can drag the green and red dots to see different secant lines. ```javascript /autoplay //smartdown.import=https://cdnjs.cloudflare.com/ajax/libs/jsxgraph/0.99.7/jsxgraphcore.js smartdown.importCssUrl('https://cdnjs.cloudflare.com/ajax/libs/jsxgraph/0.99.7/jsxgraph.css'); const myDiv = this.div; myDiv.style.width = '100%'; myDiv.style.height = '100%'; myDiv.style.margin = 'auto'; myDiv.innerHTML = ``; JXG.Options.axis.ticks.majorHeight = 40; // create the board board0 = JXG.JSXGraph.initBoard('box3', {boundingbox:[-5,10,20,-3], showCopyright:false, keepaspectratio:false, axis:false}); board0.resizeContainer(myDiv.offsetWidth, myDiv.offsetHeight); let xaxis = board0.create('axis', [[0, 0], [1,0]], {name:'x', withLabel: true, label: { fontSize: 20, position: 'rt', // possible values are 'lft', 'rt', 'top', 'bot' offset: [-20, 20] // (in pixels) } }); let yaxis = board0.create('axis', [[0, 0], [0, 1]], {name:'y', withLabel: true, label: { fontSize: 20, position: 'rt', // possible values are 'lft', 'rt', 'top', 'bot' offset: [-30, -20] // (in pixels) } }); // parabala and it's derivative let f = function(x) { return x*x; }; let df = function(x) { return 2 * x; } let graph_f = board0.create('functiongraph', [f,-10,10], {strokeColor:'#999999'}); //let graph_df = board0.create('functiongraph', [df,-10,10],{strokeColor: '#11AA66', visible:true}); // point x on axis we want to get derivative value let x = board0.create('glider', [1,0, xaxis], {name:'x', size:6}); let fx = board0.create('point', [ function() { return x.X(); }, function() { return f(x.X()); }], {name:'', color:'blue', fixed:true}); // the slider point for the secant let x_h = board0.create('glider', [x.X() + 1, 0, xaxis], {name:'x + h', size:6, color:'green'} ); // sliding point on parabala let fx_h = board0.create('point', [ function() { return x_h.X(); }, function() { return f(x_h.X()); } ], {name:'', color: 'blue', fixed: true, size:3}); // secant line let secant = board0.create('line', [fx, fx_h], {strokeColor:'blue'}); let secantSlope = function() { if (x.X() == x_h.X()) { return &quot;UNDEFINED: divide by zero&quot;; } return ((f(x.X()) - f(x_h.X()))/(x.X() - x_h.X())).toFixed(3).toString(); } let secantSlopeText = board0.create('text',[ function() { return x.X() + (x_h.X() - x.X())/2 - 1.8; }, function() { return f(x.X()) + (f(x_h.X()) - f(x.X()))/2;}, function(){ return 'slope = '+ secantSlope(); }], {fontSize:15, visible:false}); let p = board0.create('point', [ function() { return x_h.X(); }, function() { return f(x.X());}], {visible:false}); let rise = board0.create('line', [fx_h, p], {color:'black', strokeWidth:1, straightFirst:false, straightLast:false, dash:2}); let run = board0.create('line', [fx, p], {color:'black', strokeWidth:1, straightFirst:false, straightLast:false, dash:2}); let riseText = board0.create('text', [ function() { if (x_h.X() &gt; x.X()) { return x_h.X() + 0.1; } return x_h.X() - 1.5; }, function() { return (f(x_h.X()) - f(x.X()))/2 + f(x.X()); }, '(x+h)^2 - x^2'], {fontSize:12}); let runText = board0.create('text', [ function() { return x.X() + (x_h.X() - x.X())/2; }, function() { return f(x.X()) - 0.3; }, 'h'], {fontSize:12}); this.sizeChanged = function() { board0.resizeContainer(myDiv.offsetWidth, myDiv.offsetHeight); }; ``` ### Putting it all Together Here's my first prototype that attempts to maintain the mapping between the symbolic reasoning and the model. I'm using smartdown's [disclosables](https://smartdown.site/#gallery/Disclosables.md) to place the main ideas and symbolic reasoning next to the picture of the model. I don't have very much control over the positioning of the disclosables so I've made them draggable. There's a little black dot on each pop up that allows you to position them. It's also difficult to control the width of the pop ups. A two column format might be a better solution with one column holding the picture and the second containing a slide show of the main anchor points. Will talk to [Dan Keith](https://doctorbud.com) (the smartdown guy) about how to make this better. This explanation is intended for students who are taking calculus and are familiar with calculus notation and ideas so many of the terms and notations aren't defined. However, I think a non calculus student could still get the idea of what's happening here even if some of the notation and terms are unfamiliar. [start explanation](:=start=true) [derivative](:=transition4=true) ```javascript /autoplay //smartdown.import=https://cdnjs.cloudflare.com/ajax/libs/jsxgraph/0.99.7/jsxgraphcore.js smartdown.importCssUrl('https://cdnjs.cloudflare.com/ajax/libs/jsxgraph/0.99.7/jsxgraph.css'); const myDiv = this.div; myDiv.style.width = '100%'; myDiv.style.height = '100%'; myDiv.style.margin = 'auto'; myDiv.innerHTML = ``; JXG.Options.axis.ticks.majorHeight = 40; // create the board board0 = JXG.JSXGraph.initBoard('box1', {boundingbox:[-5,10,20,-3], showCopyright:false, keepaspectratio:false, axis:false}); board0.resizeContainer(myDiv.offsetWidth, myDiv.offsetHeight); let xaxis = board0.create('axis', [[0, 0], [1,0]], {name:'x', withLabel: true, label: { fontSize: 20, position: 'rt', // possible values are 'lft', 'rt', 'top', 'bot' offset: [-20, 20] // (in pixels) } }); let yaxis = board0.create('axis', [[0, 0], [0, 1]], {name:'y', withLabel: true, label: { fontSize: 20, position: 'rt', // possible values are 'lft', 'rt', 'top', 'bot' offset: [-30, -20] // (in pixels) } }); // parabala and it's derivative let f = function(x) { return x*x; }; let df = function(x) { return 2 * x; } let x = board0.create('glider', [1,0, xaxis], {name:'x', size:6}); let fx = board0.create('point', [ function() { return x.X(); }, function() { return f(x.X()); }], {name:'', color:'blue', fixed:true}); let graph_f = board0.create('functiongraph', [f,-10,10], {strokeColor:'#999999'}); let graph_df = board0.create('functiongraph', [df,-10,10], {strokeColor:'#44AA44', visible:false}); let dfx = board0.create('point', [ function() { return x.X(); }, function() { return df(x.X()); }], {name:'', color:'#44AA44', fixed:true, visible:false}); // tangent line section let tangent = board0.create('line', [ function() { return f(x.X());}, function() { return - df(x.X());}, 1], {visible:true}); let tangentSlopeText = board0.create('text',[ function() { return x.X() + 0.5; }, function() { return f(x.X()) + 0.5;}, function(){ return 'slope = '+ df(x.X()).toFixed(2); }], {fontSize:15, visible:true}); // Secant line section // the slider point for the secant let x_h = board0.create('glider', [x.X() + 1, 0, xaxis], {name:'x + h', size:6, color:'green', visible:false} ); // sliding point on parabala let fx_h = board0.create('point', [ function() { return x_h.X(); }, function() { return f(x_h.X()); } ], {name:'', color: 'blue', fixed: true, size:3, visible:false}); let secant = board0.create('line', [fx, fx_h], {strokeColor:'blue', visible:false}); let secantSlope = function() { if (x.X() == x_h.X()) { return &quot;UNDEFINED: divide by zero&quot;; } return ((f(x.X()) - f(x_h.X()))/(x.X() - x_h.X())).toFixed(3).toString(); } let secantSlopeText = board0.create('text',[ function() { return x.X() + (x_h.X() - x.X())/2 - 1.8; }, function() { return f(x.X()) + (f(x_h.X()) - f(x.X()))/2;}, function(){ return 'slope = '+ secantSlope(); }], {fontSize:15, visible:false}); let p = board0.create('point', [ function() { return x_h.X(); }, function() { return f(x.X());}], {visible:false}); let rise = board0.create('line', [fx_h, p], {color:'black', strokeWidth:1, straightFirst:false, straightLast:false, dash:2, visible:false}); let run = board0.create('line', [fx, p], {color:'black', strokeWidth:1, straightFirst:false, straightLast:false, dash:2, visible:false}); let riseText = board0.create('text', [ function() { if (x_h.X() &gt; x.X()) { return x_h.X() + 0.1; } return x_h.X() - 1.5; }, function() { return (f(x_h.X()) - f(x.X()))/2 + f(x.X()); }, '(x+h)^2 - x^2'], {fontSize:12, visible:false}); let runText = board0.create('text', [ function() { return x.X() + (x_h.X() - x.X())/2; }, function() { return f(x.X()) - 0.3; }, 'h'], {fontSize:12, visible:false}); // board0.on('update', function() { // //smartdown.setVariable('hvalue', (x_h.X() - x.X()).toFixed(3)); // }); let showTangent = function() { tangent.setAttribute({visible:true}); tangentSlopeText.setAttribute({visible:true}); }; let hideTangent = function() { tangent.setAttribute({visible:false}); tangentSlopeText.setAttribute({visible:false}); }; let showSecant = function() { x_h.setAttribute({visible:true}); fx_h.setAttribute({visible:true}); secant.setAttribute({visible:true}); secantSlopeText.setAttribute({visible:true}); rise.setAttribute({visible:true}); run.setAttribute({visible:true}); riseText.setAttribute({visible:true}); runText.setAttribute({visible:true}); }; let hideSecant = function() { x_h.setAttribute({visible:false}); fx_h.setAttribute({visible:false}); secant.setAttribute({visible:false}); secantSlopeText.setAttribute({visible:false}); rise.setAttribute({visible:false}); run.setAttribute({visible:false}); riseText.setAttribute({visible:false}); runText.setAttribute({visible:false}); }; let derivativeOn = false; let showDerivative = function() { graph_df.setAttribute({visible:true}); dfx.setAttribute({visible:true}); }; let hideDerivative = function() { graph_df.setAttribute({visible:false}); dfx.setAttribute({visible:false}); }; this.sizeChanged = function() { board0.resizeContainer(myDiv.offsetWidth, myDiv.offsetHeight); }; smartdown.setVariable('start', false); smartdown.setVariable('transition1', false); smartdown.setVariable('transition2', false); smartdown.setVariable('transition3', false); smartdown.setVariable('transition4', false); smartdown.setVariable('hValue', 1); board0.on('update', function() { smartdown.setVariable('hValue', (x_h.X() - x.X()).toFixed(3)); }); this.dependOn = ['start', 'transition1', 'transition2', 'transition3', 'transition4']; this.depend = function() { if (env.start == true) { smartdown.showDisclosure('mi1', '', 'bottomright,shadow,draggable'); smartdown.hideDisclosure('mi2', '', 'bottomright,shadow,draggable'); smartdown.hideDisclosure('mi3', '', 'bottomright,shadow,draggable'); hideSecant(); showTangent(); smartdown.setVariable('start',false); } // board0.suspendUpdate(); if (env.transition1 == true) { hideSecant(); showTangent(); smartdown.setVariable('transition1', false); smartdown.showDisclosure('mi1', '', 'bottomright,shadow,draggable'); smartdown.hideDisclosure('mi2', '', 'bottomright,shadow,draggable'); } if (env.transition2 == true) { x.moveTo([1,0]); showSecant(); hideTangent(); smartdown.setVariable('transition2', false); smartdown.showDisclosure('mi2', '', 'bottomright,shadow,draggable'); smartdown.hideDisclosure('mi1', '', 'bottomright,shadow,draggable'); smartdown.hideDisclosure('mi3', '', 'bottomright,shadow,draggable'); } if (env.transition3 == true) { smartdown.setVariable('transition3', false); smartdown.showDisclosure('mi3', '', 'bottomright,shadow,draggable'); smartdown.hideDisclosure('mi2', '', 'bottomright,shadow,draggable'); } if (env.transition4 == true) { if (derivativeOn) { hideDerivative(); } else { showDerivative(); } derivativeOn = !derivativeOn; smartdown.setVariable('transition4', false); } // board0.unsuspendUpdate(); }; ``` ### Conclusion I plan to show this to Dan this week to give him a sense of what I want to achieve with these types of explanations. The main goal is to keep all three parts of the explanation integrated so the reader never loses track of the big picture and the meaning of notational statements. I hope to build and post an improved prototype soon. Then I can easily integrate this approach into all my explanations. # :::: mi1 ### Finding the Derivative We want to find a function that tells us the **slope** of the tangent line for the function $f(x)=x^2$. Drag the red dot to see the slope of the tangent line. [Next](:=transition2=true) # :::: # :::: mi2 ### Derivatives are Slopes The derivative definition starts with the **slope** of a secant line. See if you can understand why this expression describes the slope by looking at the picture. $$\frac{(x + h)^2 - x^2}{h}$$ [Do some algebra](::algebra/button,transparent) # :::: algebra $$ \begin{align} \frac{x^2 + 2hx + h^2 - x^2}{h} &amp; &amp; \textrm{combine like terms} \newline \frac{2hx + h^2}{h} &amp; &amp; \textrm{cancel $h$ terms} \newline 2x + h &amp; \end{align} $$ The expression $2x + h$ represents the **slope** of the secant line for all values of $x$ and $h$. # :::: [Back](:=transition1=true) [Next](:=transition3=true) # :::: # :::: mi3 #### Turn a Secant into a Tangent We can use a **limit** to turn a secant into a tangent. If we drag the green dot $x+h$ towards the red $x$ dot - the value of $h$ gets very small. **h** = [](:!hValue) - the secant gets closer to the tangent - the slope of the secant $2x + h$ gets close to $2x$. We write this as $$f'(x) = \lim_{h \to 0} 2x + h = 2x$$ The derivative of $f(x) = x^2$ is the function $$f'(x) = 2x$$ [Back](:=transition2=true) [Close](::mi3) # :::: # :::: pulldown1 [](:Xa1) price of tea in China [](:Xa2) 10 meters [](:Xa3) slope of the secant line # :::: ```javascript/autoplay smartdown.setVariable('a1', false); smartdown.setVariable('a2', false); smartdown.setVariable('a3', false); smartdown.setVariable('secantSlope', '________'); this.dependOn = ['a1', 'a2', 'a3']; this.depend = function() { if (env.a1 == false &amp;&amp; env.a2 == false &amp;&amp; env.a3 == true) { smartdown.setVariable('secantSlope', 'slope of the secant line'); smartdown.showDisclosure('correct','','bottomright,transparent,shadow'); setTimeout(function () { smartdown.hideDisclosure('correct','','bottomright'); }, 3000); } }; ``` # :::: correct # --colorbox right correct! :grinning: # --colorbox # ::::</summary></entry><entry><title type="html">USAMTS Competition Problem Explorables: Problem 2</title><link href="https://wildthinks.org/posts/usamts2/" rel="alternate" type="text/html" title="USAMTS Competition Problem Explorables: Problem 2" /><published>2020-01-29T00:00:00-08:00</published><updated>2020-01-29T00:00:00-08:00</updated><id>https://wildthinks.org/posts/usamts2</id><content type="html" xml:base="https://wildthinks.org/posts/usamts2/">The USA Mathematical Talent Search [USAMTS](https://www.usamts.org) is a unique mathematical competition for middle school and high school students.  Previous competitions contain a treasure trove of challenging, thought provoking and remarkably accessible problems.  I'm writing some interactive apps for a few these problems so that it's easier for more people to get to the heart of each problem.  This problem is part of the 2019-2020 year problems, but it was in the first problem set and was due back in October 2019.  So it's too late for a submission and fair game for discussion.  This is the second problem I've presented.  You can find the previous USAMTS problem [here](/posts/usamts1).


### USAMTS 2019-2020 Problem Set 1 

**4/1/31.** A group of $100$ friends stands in a circle. Initially, one person has $2019$ mangos, and no one else has mangos. The friends split the mangos according to the following rules:
  - *sharing* : to share, a friend passes two mangos to the left and one mango to the right.
  - *eating* : the mangos must also be eaten and enjoyed. However, no friend wants to be selfish and eat too many mangos. Every time a person eats a mango, they must also pass another mango to the right.

A person may only *share* if they have at least three mangos, and they may only *eat* if they have at least two mangos. The friends continue sharing and eating, until so many mangos have been eaten that no one is able to share or eat anymore.

Show that there are exactly eight people stuck with mangos, which can no longer be shared or eaten.

##### Interactive App

It's hard to model all $100$ people in an app.  The mangos get really small and you don't really want to work $2019$ mangos around $100$ people, trust me.  This app starts with $12$ people and you can add as many mangos to the circle as you want.  Hover over the app instructions to get the full details. Currently this app doesn't work well on mobile devices.  I hope to improve the mobile experience soon.

# :::: app_instructions
- add mangos by clicking on the start box/person.
- drag a mango clockwise one box to share mangos.
- drag a mango counter clockwise one box to eat a mango.
- change the number of people with the slider and then reset the app by hitting the gray stop/play button above the app.  This will reset the app with the new number of people.

# ::::

```javascript /autoplay
  smartdown.setVariable('N', 12);
```

[Application Instructions](::app_instructions/tooltip) 
Number of People [](:-N/8/32/2) [](:!N)
```javascript /playable/autoplay/p5js

// import the dots library
//smartdown.import=/assets/libs/mangoDots.js

// this is the url for the background picture
const bgURL = '/assets/images/posts/andreBackground.svg';


// Adjust the surrounding DIV(s) a little
const myDiv = this.div;                                  // This chunk of code is some HTML/CSS stuff
myDiv.style.position = 'relative';                       // to make the playable look pretty
myDiv.style['background-image'] = `url(${bgURL})`;
myDiv.style['background-repeat'] = 'no-repeat';
myDiv.style['background-size'] = 'cover';
myDiv.style.height = '100%';
myDiv.style.width = '100%';
myDiv.style.padding = '0';
myDiv.style.margin = '0';
myDiv.style.overflow = 'hidden';
//myDiv.style.border = '5px solid gray';
this.div.style.margin = '10px auto'; // shorthand for '10px auto 10px auto'
this.div.innerHTML = '';

const heightScale = 0.8;
const widthScale = 0.8;
const base = 2;               // set the base for the machine
const numberBoxes = 10;         // set how many boxes you want

var dots1 = new dotlib.Dots(p5, this.div);  // create the dots and boxes machine

p5.setup = function() {                          // this function is called when you start the
                                                 // playable.

  dots1.setup(env.N);                 // initialize with the base and number of boxes.
  const canvasHeight = p5.windowHeight * heightScale;
  const canvasWidth = p5.windowWidth * widthScale;  // set the size of the playable
  p5.createCanvas(canvasWidth,canvasHeight);     // create the canvas we will draw on
  p5.windowResized();

  dots1.loadSounds();                             // load the sounds for the app
 
  p5.noLoop();
  // EnergyHack to inhibit looping after 1 sec, this allows for popups to
  // fade in (which should really be a CSS function, and not involve P5JS.
  // window.setTimeout(function() {
  //   p5.noLoop();
  // }, 10000);
};


p5.windowResized = function() {                  // this function is called when the user changes
  const canvasHeight = p5.windowHeight * heightScale;  // the size of the window.  It will rescale all the
  const canvasWidth = p5.windowWidth * widthScale;   // components to fit into the new window size.

  dots1.windowResized(canvasWidth, canvasHeight);
  p5.resizeCanvas(canvasWidth, canvasHeight);
}


p5.draw = function() {                           // this function gets called repeatedly in a loop.
  dots1.draw();                                   // The machine is redrawn multiple times a second.
}


p5.mousePressed = function()                     // this function is called everytime the user clicks the mouse
{
  // EnergyHack to enable looping for duration of drag.
  p5.loop();

  dots1.mousePressed();
}


p5.mouseDragged = function() {                   // this function is called everytime the user drags the mouse
  dots1.mouseDragged();
}


p5.mouseReleased = function() {                  // this function is called when the user releases the mouse
  dots1.mouseReleased();                          // button after a click.

  // EnergyHack to stop looping 5 sec after release.
  // window.setTimeout(function() {
  //   p5.noLoop();
  // }, 10000);
}

```

### Resources

If you liked this problem or want to check out some resources that might help you think about the problem, I suggest:

1. [Exploding Dots Interactive Web Experience](https://www.explodingdots.org/)
2. [G'Day Math: Exploding Dots Course](https://gdaymath.com/courses/exploding-dots/)

The following videos also might be helpful.

![halfwidth](https://www.youtube.com/watch?v=R4d2qQ7aeFg)

![halfwidth](https://www.youtube.com/watch?v=jvf6qXLaXAo)

This problem suggest other interesting questions.  For example, what is the minimum number of mangos you need to add to make sure every one gets to eat one?  How do you do the sharing and eating to make this happen?  If you come up with other interesting questions or have a bug report  please leave a comment.</content><author><name>Heidi Dixon</name></author><summary type="html">The USA Mathematical Talent Search [USAMTS](https://www.usamts.org) is a unique mathematical competition for middle school and high school students. Previous competitions contain a treasure trove of challenging, thought provoking and remarkably accessible problems. I'm writing some interactive apps for a few these problems so that it's easier for more people to get to the heart of each problem. This problem is part of the 2019-2020 year problems, but it was in the first problem set and was due back in October 2019. So it's too late for a submission and fair game for discussion. This is the second problem I've presented. You can find the previous USAMTS problem [here](/posts/usamts1). ### USAMTS 2019-2020 Problem Set 1 **4/1/31.** A group of $100$ friends stands in a circle. Initially, one person has $2019$ mangos, and no one else has mangos. The friends split the mangos according to the following rules: - *sharing* : to share, a friend passes two mangos to the left and one mango to the right. - *eating* : the mangos must also be eaten and enjoyed. However, no friend wants to be selfish and eat too many mangos. Every time a person eats a mango, they must also pass another mango to the right. A person may only *share* if they have at least three mangos, and they may only *eat* if they have at least two mangos. The friends continue sharing and eating, until so many mangos have been eaten that no one is able to share or eat anymore. Show that there are exactly eight people stuck with mangos, which can no longer be shared or eaten. ##### Interactive App It's hard to model all $100$ people in an app. The mangos get really small and you don't really want to work $2019$ mangos around $100$ people, trust me. This app starts with $12$ people and you can add as many mangos to the circle as you want. Hover over the app instructions to get the full details. Currently this app doesn't work well on mobile devices. I hope to improve the mobile experience soon. # :::: app_instructions - add mangos by clicking on the start box/person. - drag a mango clockwise one box to share mangos. - drag a mango counter clockwise one box to eat a mango. - change the number of people with the slider and then reset the app by hitting the gray stop/play button above the app. This will reset the app with the new number of people. # :::: ```javascript /autoplay smartdown.setVariable('N', 12); ``` [Application Instructions](::app_instructions/tooltip) Number of People [](:-N/8/32/2) [](:!N) ```javascript /playable/autoplay/p5js // import the dots library //smartdown.import=/assets/libs/mangoDots.js // this is the url for the background picture const bgURL = '/assets/images/posts/andreBackground.svg'; // Adjust the surrounding DIV(s) a little const myDiv = this.div; // This chunk of code is some HTML/CSS stuff myDiv.style.position = 'relative'; // to make the playable look pretty myDiv.style['background-image'] = `url(${bgURL})`; myDiv.style['background-repeat'] = 'no-repeat'; myDiv.style['background-size'] = 'cover'; myDiv.style.height = '100%'; myDiv.style.width = '100%'; myDiv.style.padding = '0'; myDiv.style.margin = '0'; myDiv.style.overflow = 'hidden'; //myDiv.style.border = '5px solid gray'; this.div.style.margin = '10px auto'; // shorthand for '10px auto 10px auto' this.div.innerHTML = ''; const heightScale = 0.8; const widthScale = 0.8; const base = 2; // set the base for the machine const numberBoxes = 10; // set how many boxes you want var dots1 = new dotlib.Dots(p5, this.div); // create the dots and boxes machine p5.setup = function() { // this function is called when you start the // playable. dots1.setup(env.N); // initialize with the base and number of boxes. const canvasHeight = p5.windowHeight * heightScale; const canvasWidth = p5.windowWidth * widthScale; // set the size of the playable p5.createCanvas(canvasWidth,canvasHeight); // create the canvas we will draw on p5.windowResized(); dots1.loadSounds(); // load the sounds for the app p5.noLoop(); // EnergyHack to inhibit looping after 1 sec, this allows for popups to // fade in (which should really be a CSS function, and not involve P5JS. // window.setTimeout(function() { // p5.noLoop(); // }, 10000); }; p5.windowResized = function() { // this function is called when the user changes const canvasHeight = p5.windowHeight * heightScale; // the size of the window. It will rescale all the const canvasWidth = p5.windowWidth * widthScale; // components to fit into the new window size. dots1.windowResized(canvasWidth, canvasHeight); p5.resizeCanvas(canvasWidth, canvasHeight); } p5.draw = function() { // this function gets called repeatedly in a loop. dots1.draw(); // The machine is redrawn multiple times a second. } p5.mousePressed = function() // this function is called everytime the user clicks the mouse { // EnergyHack to enable looping for duration of drag. p5.loop(); dots1.mousePressed(); } p5.mouseDragged = function() { // this function is called everytime the user drags the mouse dots1.mouseDragged(); } p5.mouseReleased = function() { // this function is called when the user releases the mouse dots1.mouseReleased(); // button after a click. // EnergyHack to stop looping 5 sec after release. // window.setTimeout(function() { // p5.noLoop(); // }, 10000); } ``` ### Resources If you liked this problem or want to check out some resources that might help you think about the problem, I suggest: 1. [Exploding Dots Interactive Web Experience](https://www.explodingdots.org/) 2. [G'Day Math: Exploding Dots Course](https://gdaymath.com/courses/exploding-dots/) The following videos also might be helpful. ![halfwidth](https://www.youtube.com/watch?v=R4d2qQ7aeFg) ![halfwidth](https://www.youtube.com/watch?v=jvf6qXLaXAo) This problem suggest other interesting questions. For example, what is the minimum number of mangos you need to add to make sure every one gets to eat one? How do you do the sharing and eating to make this happen? If you come up with other interesting questions or have a bug report please leave a comment.</summary></entry><entry><title type="html">USAMTS Competition Problem Explorables</title><link href="https://wildthinks.org/posts/usamts1/" rel="alternate" type="text/html" title="USAMTS Competition Problem Explorables" /><published>2020-01-17T00:00:00-08:00</published><updated>2020-01-17T00:00:00-08:00</updated><id>https://wildthinks.org/posts/usamts1</id><content type="html" xml:base="https://wildthinks.org/posts/usamts1/">The USA Mathematical Talent Search [USAMTS](https://www.usamts.org) is a unique mathematical competition for middle school and high school students.  Previous competitions contain a treasure trove of challenging, thought provoking and remarkably accessible problems.  I'm going to write some interactive apps for a few these problems so that it's easier for more people to get to the heart of each problem.  Here's the first problem. 


### USAMTS 2018-2019 Problem Set 1 

**4/1/30**. Right triangle $\triangle ABC$ has $\angle C = 90^{\circ}$. A fly is trapped inside $\triangle ABC$. It starts at point $D$, the foot of the altitude from $C$ to $\overline{AB}$, and then makes a (finite) sequence of moves. In each move, it flies in a direction parallel to either $\overline{AC}$ or $\overline{BC}$; upon reaching a leg of the triangle, it then flies to a point on $\overline{AB}$ in a direction parallel to $\overline{CD}$. For example, on its first move, the fly can move to either of the points [Y1](:=Y1=true) or [Y2](:=Y2=true), as shown.

Let $P$ and $Q$ be distinct points on $\overline{AB}$. Show that the fly can reach some point on $\overline{PQ}$. [Show P and Q](:=reset=true)

```javascript /playable/autoplay/p5js

// this code is html code to make the app size and background
const myDiv = this.div;
myDiv.style.width = '100%';
myDiv.style.height = '100%';
myDiv.style.margin = 'auto';
myDiv.style.background = '#EEEEEE';
myDiv.style.borderRadius = '8px';


// this is a bunch of variables for the size of the app window
// it needs to change when the user resizes the web page
const widthScale = 0.7;
const heightScale = 0.4;
let canvasWidth = p5.windowWidth * widthScale;  // set the size of the playable
let canvasHeight = p5.windowWidth * heightScale;
let xMargin = canvasWidth * 0.1;   // margins for the main triangle
let yMargin = xMargin;
let unit = canvasWidth - 2 * xMargin;  // how wide should the triangle be


// we keep track of the number of clicks so we can 
// 1. set the green target interval
// 2. set the position of first point
let numClicks = 0;  
let pink = [250,20,100];
let showPQ = false;

// our X and Y points are between 0 and 1.  We need to convert them to 'pixels' to scale
// them to the size of the app window.
let getX = function(x) {
  return x * unit + xMargin;
};

let getY = function(y) {
  return canvasHeight - yMargin - y * unit;
};


// these are constants that define the triangle
let a = 1; // x intercept. this should always be 1.  it's the width of the triangle
let c = 0.5; // y intercept.  it's the height of triangle.  must be between 0 and 1.
let m =  - c / a; // slope of the hypotenuse
let orthoM = - 1 / m;  // slope that is 90 degrees to hypotenuse
let f = function(x) { return m * x + c; }; // returns a point on the hypotenuse


// plug in a point and it will return a point that is on the hypotenuse and also on
// an altitude through the given point.
let altPoint = function(x,y) { 
  const b = y + x / m;
  const newX = m * (b - c) / (m*m + 1);
  const newY = f(newX);
  return [newX , newY];
};

// this is a starting point on the hypotenuse
let [startX, startY] = altPoint(0,0);
let X = startX;
let Y = startY;


// find the X coordinate (relative to triangle) from a mouse position (relative to app window)
let getXfromMousePosition = function(p) {
  if (p &lt; xMargin) return 0;
  if (p &gt; canvasWidth - xMargin) return a;
  return (p - xMargin) / unit;
};

let drawTargetInterval = function() {
  p5.push();
  p5.stroke(100,255,100);
  p5.line(getX(env.P),getY(f(env.P)), getX(env.Q), getY(f(env.Q)));

  p5.fill('black');
  p5.stroke('black');
  p5.strokeWeight(1);
  p5.text('P', getX(env.P), getY(f(env.P)) - 10);
  p5.text('Q', getX(env.Q), getY(f(env.Q)) - 10);
  p5.ellipse(getX(env.P), getY(f(env.P)), 5);
  p5.ellipse(getX(env.Q), getY(f(env.Q)), 5);
  p5.pop();
};

let drawY1 = function() {
  p5.push();
  X = startX;
  Y = startY
  makeMove(startX, 0);
  p5.fill('black');
  p5.text('Y1', getX(X), getY(Y) - 10);
  p5.ellipse(getX(X), getY(Y), 5);
  X = startX;
  Y = startY
  p5.pop();
};


let drawY2 = function() {
  p5.push();
  X = startX;
  Y = startY
  makeMove(0, startY);
  p5.fill('black');
  p5.text('Y2', getX(X), getY(Y) - 10);
  p5.ellipse(getX(X), getY(Y), 5);
  X = startX;
  Y = startY
  p5.pop();
};


let drawTriangle = function() {
  p5.clear();
  p5.push();

  p5.fill('white');
  p5.stroke('black');
  p5.strokeWeight(2);
  // draw the main triangle
  p5.triangle(getX(0), getY(0), getX(a), getY(0), getX(0), getY(c)); 

  let sz = 0.02;
  p5.line(getX(sz), getY(sz), getX(0), getY(sz));
  p5.line(getX(sz), getY(sz), getX(sz), getY(0));
  
  // draw the triangle altitude
  const [aX,aY] = altPoint(0,0);
  p5.stroke(0,0,200);
  p5.line(getX(0), getY(0), getX(aX), getY(aY));
  

  p5.fill('black');
  p5.stroke('black');
  p5.strokeWeight(1);
  p5.ellipse(getX(aX), getY(aY), 5);

  p5.text('A', getX(0), getY(c) - 10);
  p5.text('B', getX(a), getY(0) + 15);
  p5.text('C', getX(0), getY(0) + 15);
  p5.text('D', getX(aX), getY(aY) - 10);
  
  
  p5.circle(getX(0), getY(c), 5);
  p5.circle(getX(a), getY(0), 5);
  p5.circle(getX(0), getY(0), 5);

  if (showPQ) {
    drawTargetInterval();
  }
  
  // draw the start point
  p5.fill(pink);
  p5.ellipse(getX(X), getY(Y), 10);

  p5.pop();
};

p5.setup = function() {                          // this function is called when you start the app

  p5.createCanvas(canvasWidth,canvasHeight);     // create the canvas we will draw on
  p5.windowResized();  
  p5.noLoop();                                  
};


p5.windowResized = function() {                  // this function is called when the user changes
  canvasWidth = p5.windowWidth * widthScale;  // the size of the window.  It will rescale all the
  canvasHeight = p5.windowWidth * heightScale;    // components to fit into the new window size.
  p5.resizeCanvas(canvasWidth, canvasHeight);

  xMargin = canvasWidth * 0.1;   // margins for the main triangle
  yMargin = xMargin;
  unit = canvasWidth - 2 * xMargin;  // how wide should the triangle be
  drawTriangle();

}


p5.draw = function() {                           // this function gets called repeatedly in a loop.

}



let makeMove = function( moveX, moveY ) 
{
  p5.push()
  p5.fill(pink);
  p5.noStroke();
  p5.ellipse(getX(X), getY(Y), 5);  // draw the point
  p5.stroke(pink)
  p5.strokeWeight(1);

  p5.line(getX(X),getY(Y),getX(moveX),getY(moveY));  // draw the line to axis
  const [xP, yP] = altPoint(moveX,moveY);
  p5.line(getX(moveX),getY(moveY), getX(xP), getY(yP));  // draw the next altitude line
  X = xP;                                                // udate new value of x and y
  Y = yP;
  p5.pop();
}

p5.mousePressed = function() {

  if (p5.mouseX &gt; 0 + xMargin &amp;&amp; 
    p5.mouseX &lt; canvasWidth - xMargin &amp;&amp; 
    p5.mouseY &gt; 0 &amp;&amp; 
    p5.mouseY &lt; canvasHeight) {
    X = getXfromMousePosition(p5.mouseX);
    Y = f(X);
    drawTriangle();
  }

}

smartdown.setVariable('P', 0.7);
smartdown.setVariable('Q', 0.8);
smartdown.setVariable('left', false);
smartdown.setVariable('down', false);
smartdown.setVariable('reset', false);
smartdown.setVariable('Y1', false);
smartdown.setVariable('Y2', false);

let prevP = 0.1;
let prevQ = 0.5;
this.dependOn = ['P', 'Q', 'left', 'down', 'reset', 'Y1', 'Y2'];
this.depend = function() {

  if (env.left == true) {
    smartdown.setVariable('left', false);
    makeMove(0, Y);
  }
  if (env.down == true) {
      smartdown.setVariable('down', false);
      makeMove(X, 0);
  }

  if (env.Y1 == true){
    smartdown.setVariable('Y1', false);
    drawY1();
  }

  if (env.Y2 == true){
    smartdown.setVariable('Y2', false);
    drawY2();
  }

  if (prevP != env.P || prevQ != env.Q || env.reset == true) {
      
      if (env.reset == true) {
        showPQ = true;
        smartdown.setVariable('reset', false);
      } 
      
      prevP = env.P;
      prevQ = env.Q;
      const [rx, ry] = altPoint(0,0);
      X = rx;
      Y = ry;
      drawTriangle();
  }
};

```
[P](:-P/0/1/0.01)  
[Q](:-Q/0/1/0.01)
[fly left](:=left=true) [fly down](:=down=true) [reset](:=reset=true) [Application Notes](::appnotes/tooltip)

# :::: appnotes
- you can adjust the interval $[P,Q]$ with the $P$ and $Q$ sliders.
- use the buttons to fly left, fly down or reset the app to start over.
- you can click on segment $\overline{AB}$ to reset the app and start a flight path from a specific point on  $\overline{AB}$.
# ::::</content><author><name>Heidi Dixon</name></author><summary type="html">The USA Mathematical Talent Search [USAMTS](https://www.usamts.org) is a unique mathematical competition for middle school and high school students. Previous competitions contain a treasure trove of challenging, thought provoking and remarkably accessible problems. I'm going to write some interactive apps for a few these problems so that it's easier for more people to get to the heart of each problem. Here's the first problem. ### USAMTS 2018-2019 Problem Set 1 **4/1/30**. Right triangle $\triangle ABC$ has $\angle C = 90^{\circ}$. A fly is trapped inside $\triangle ABC$. It starts at point $D$, the foot of the altitude from $C$ to $\overline{AB}$, and then makes a (finite) sequence of moves. In each move, it flies in a direction parallel to either $\overline{AC}$ or $\overline{BC}$; upon reaching a leg of the triangle, it then flies to a point on $\overline{AB}$ in a direction parallel to $\overline{CD}$. For example, on its first move, the fly can move to either of the points [Y1](:=Y1=true) or [Y2](:=Y2=true), as shown. Let $P$ and $Q$ be distinct points on $\overline{AB}$. Show that the fly can reach some point on $\overline{PQ}$. [Show P and Q](:=reset=true) ```javascript /playable/autoplay/p5js // this code is html code to make the app size and background const myDiv = this.div; myDiv.style.width = '100%'; myDiv.style.height = '100%'; myDiv.style.margin = 'auto'; myDiv.style.background = '#EEEEEE'; myDiv.style.borderRadius = '8px'; // this is a bunch of variables for the size of the app window // it needs to change when the user resizes the web page const widthScale = 0.7; const heightScale = 0.4; let canvasWidth = p5.windowWidth * widthScale; // set the size of the playable let canvasHeight = p5.windowWidth * heightScale; let xMargin = canvasWidth * 0.1; // margins for the main triangle let yMargin = xMargin; let unit = canvasWidth - 2 * xMargin; // how wide should the triangle be // we keep track of the number of clicks so we can // 1. set the green target interval // 2. set the position of first point let numClicks = 0; let pink = [250,20,100]; let showPQ = false; // our X and Y points are between 0 and 1. We need to convert them to 'pixels' to scale // them to the size of the app window. let getX = function(x) { return x * unit + xMargin; }; let getY = function(y) { return canvasHeight - yMargin - y * unit; }; // these are constants that define the triangle let a = 1; // x intercept. this should always be 1. it's the width of the triangle let c = 0.5; // y intercept. it's the height of triangle. must be between 0 and 1. let m = - c / a; // slope of the hypotenuse let orthoM = - 1 / m; // slope that is 90 degrees to hypotenuse let f = function(x) { return m * x + c; }; // returns a point on the hypotenuse // plug in a point and it will return a point that is on the hypotenuse and also on // an altitude through the given point. let altPoint = function(x,y) { const b = y + x / m; const newX = m * (b - c) / (m*m + 1); const newY = f(newX); return [newX , newY]; }; // this is a starting point on the hypotenuse let [startX, startY] = altPoint(0,0); let X = startX; let Y = startY; // find the X coordinate (relative to triangle) from a mouse position (relative to app window) let getXfromMousePosition = function(p) { if (p canvasWidth - xMargin) return a; return (p - xMargin) / unit; }; let drawTargetInterval = function() { p5.push(); p5.stroke(100,255,100); p5.line(getX(env.P),getY(f(env.P)), getX(env.Q), getY(f(env.Q))); p5.fill('black'); p5.stroke('black'); p5.strokeWeight(1); p5.text('P', getX(env.P), getY(f(env.P)) - 10); p5.text('Q', getX(env.Q), getY(f(env.Q)) - 10); p5.ellipse(getX(env.P), getY(f(env.P)), 5); p5.ellipse(getX(env.Q), getY(f(env.Q)), 5); p5.pop(); }; let drawY1 = function() { p5.push(); X = startX; Y = startY makeMove(startX, 0); p5.fill('black'); p5.text('Y1', getX(X), getY(Y) - 10); p5.ellipse(getX(X), getY(Y), 5); X = startX; Y = startY p5.pop(); }; let drawY2 = function() { p5.push(); X = startX; Y = startY makeMove(0, startY); p5.fill('black'); p5.text('Y2', getX(X), getY(Y) - 10); p5.ellipse(getX(X), getY(Y), 5); X = startX; Y = startY p5.pop(); }; let drawTriangle = function() { p5.clear(); p5.push(); p5.fill('white'); p5.stroke('black'); p5.strokeWeight(2); // draw the main triangle p5.triangle(getX(0), getY(0), getX(a), getY(0), getX(0), getY(c)); let sz = 0.02; p5.line(getX(sz), getY(sz), getX(0), getY(sz)); p5.line(getX(sz), getY(sz), getX(sz), getY(0)); // draw the triangle altitude const [aX,aY] = altPoint(0,0); p5.stroke(0,0,200); p5.line(getX(0), getY(0), getX(aX), getY(aY)); p5.fill('black'); p5.stroke('black'); p5.strokeWeight(1); p5.ellipse(getX(aX), getY(aY), 5); p5.text('A', getX(0), getY(c) - 10); p5.text('B', getX(a), getY(0) + 15); p5.text('C', getX(0), getY(0) + 15); p5.text('D', getX(aX), getY(aY) - 10); p5.circle(getX(0), getY(c), 5); p5.circle(getX(a), getY(0), 5); p5.circle(getX(0), getY(0), 5); if (showPQ) { drawTargetInterval(); } // draw the start point p5.fill(pink); p5.ellipse(getX(X), getY(Y), 10); p5.pop(); }; p5.setup = function() { // this function is called when you start the app p5.createCanvas(canvasWidth,canvasHeight); // create the canvas we will draw on p5.windowResized(); p5.noLoop(); }; p5.windowResized = function() { // this function is called when the user changes canvasWidth = p5.windowWidth * widthScale; // the size of the window. It will rescale all the canvasHeight = p5.windowWidth * heightScale; // components to fit into the new window size. p5.resizeCanvas(canvasWidth, canvasHeight); xMargin = canvasWidth * 0.1; // margins for the main triangle yMargin = xMargin; unit = canvasWidth - 2 * xMargin; // how wide should the triangle be drawTriangle(); } p5.draw = function() { // this function gets called repeatedly in a loop. } let makeMove = function( moveX, moveY ) { p5.push() p5.fill(pink); p5.noStroke(); p5.ellipse(getX(X), getY(Y), 5); // draw the point p5.stroke(pink) p5.strokeWeight(1); p5.line(getX(X),getY(Y),getX(moveX),getY(moveY)); // draw the line to axis const [xP, yP] = altPoint(moveX,moveY); p5.line(getX(moveX),getY(moveY), getX(xP), getY(yP)); // draw the next altitude line X = xP; // udate new value of x and y Y = yP; p5.pop(); } p5.mousePressed = function() { if (p5.mouseX &gt; 0 + xMargin &amp;&amp; p5.mouseX 0 &amp;&amp; p5.mouseY &lt; canvasHeight) { X = getXfromMousePosition(p5.mouseX); Y = f(X); drawTriangle(); } } smartdown.setVariable('P', 0.7); smartdown.setVariable('Q', 0.8); smartdown.setVariable('left', false); smartdown.setVariable('down', false); smartdown.setVariable('reset', false); smartdown.setVariable('Y1', false); smartdown.setVariable('Y2', false); let prevP = 0.1; let prevQ = 0.5; this.dependOn = ['P', 'Q', 'left', 'down', 'reset', 'Y1', 'Y2']; this.depend = function() { if (env.left == true) { smartdown.setVariable('left', false); makeMove(0, Y); } if (env.down == true) { smartdown.setVariable('down', false); makeMove(X, 0); } if (env.Y1 == true){ smartdown.setVariable('Y1', false); drawY1(); } if (env.Y2 == true){ smartdown.setVariable('Y2', false); drawY2(); } if (prevP != env.P || prevQ != env.Q || env.reset == true) { if (env.reset == true) { showPQ = true; smartdown.setVariable('reset', false); } prevP = env.P; prevQ = env.Q; const [rx, ry] = altPoint(0,0); X = rx; Y = ry; drawTriangle(); } }; ``` [P](:-P/0/1/0.01) [Q](:-Q/0/1/0.01) [fly left](:=left=true) [fly down](:=down=true) [reset](:=reset=true) [Application Notes](::appnotes/tooltip) # :::: appnotes - you can adjust the interval $[P,Q]$ with the $P$ and $Q$ sliders. - use the buttons to fly left, fly down or reset the app to start over. - you can click on segment $\overline{AB}$ to reset the app and start a flight path from a specific point on $\overline{AB}$. # ::::</summary></entry><entry><title type="html">Interactive Calculus Primer Part I</title><link href="https://wildthinks.org/posts/calculus1/" rel="alternate" type="text/html" title="Interactive Calculus Primer Part I" /><published>2020-01-06T00:00:00-08:00</published><updated>2020-01-06T00:00:00-08:00</updated><id>https://wildthinks.org/posts/calculus1</id><content type="html" xml:base="https://wildthinks.org/posts/calculus1/">When students finish their high school calculus classes, they will likely remember many of the short cut rules for how to take the derivative of different types of functions (definitely useful!).  They often don't remember how these rules were derived and they may not remember the Fundamental Theorem of Calculus or have any intuition as to why it is true.  In other words, they emerge from these classes without intuition or awe about the main ideas of calculus.  

I'm on a mission to make this better.  I want to make an interactive online Calculus Primer.  It will be an activity that you do before starting a calculus class that helps build the intuition for what's coming.  It will avoid calculus notations and terminology.  It will not contain messy algebra.  It will focus on geometric models and building intuition.  I have a tight time schedule since my oldest son will start his first calculus class this summer and I want to get him off to a good start.  This post is the first in a series.  I've got more ideas than I can fit into one post and I have just as many unanswered questions.  

### My First Idea: Geometric Intuition for The Fundamental Theorem of Calculus
Calculus is a fancy way of studying rates of change.  Kids start learning about rates in middle school.

# --outlinebox
**Example**
 If a kid eats three slices of pizza a day, how many slices will they eat in 5 days?  

**Solution**
The total pizza eaten is equal to the number of slices per day times the number of days.
$$15 = 3 \; \frac{\text{slices}}{\text{day}} \; \times 5 \; \text{days}$$
# --outlinebox

In this case, the amount of pizza is changing relative to the number of days. More generally, we have some quantity $Y$ that is changing relative to some other quantity $X$. The total change in $Y$ is equal to the rate of change $\frac{\Delta Y}{\Delta X}$  times the units of $X$.  In practice, I think the most intuitive rate of change problem to think about is a moving object.  The distance traveled by an object is equal to the rate (or speed) of the object times the time spent moving.
$$\text{distance} = \text{rate} \; \times \; \text{time}. $$
For now, let's assume we're talking about a moving car and just remember that all of this can be generalized to anything that has a rate of change.

So we're talking about a moving car, and we have this relationship $d = r \times t$, but there are two ways to write it and they each have a different geometric representation. If we know the rate and the time, then finding the distance is a multiplication problem which we can model as an area problem. [show area](:=speedToggle=true)  If the length and width of the rectangle have the values of *rate* and *time*, then the area of the rectangle will be the *distance* traveled.

Now imagine instead that we have the distance and the time and we want to find the rate. We write this formula as $r = \frac{d}{t}$.  Finding the rate in terms of distance and time is a division problem which we can model as the slope of a line. [show slope](:=distanceToggle=true)   

[Application Instructions](::instructions1/tooltip)
```javascript /playable/autoplay
//smartdown.import=https://cdnjs.cloudflare.com/ajax/libs/jsxgraph/0.99.7/jsxgraphcore.js

smartdown.importCssUrl('https://cdnjs.cloudflare.com/ajax/libs/jsxgraph/0.99.7/jsxgraph.css');

const myDiv = this.div;
myDiv.style.width = '100%';
myDiv.style.height = '100%';
myDiv.style.margin = 'auto';
myDiv.innerHTML = `&lt;div id='box1' class='jxgbox' style='height:400px;'&gt;`;


JXG.Options.axis.ticks.majorHeight = 40;
// create the board
board0 = JXG.JSXGraph.initBoard('box1', {boundingbox:[-2,7,10,-1], keepaspectratio:true, axis:false});

var xaxis = board0.create('axis', [[0, 0], [1,0]], 
      {name:'time (s)', 
      withLabel: true,
      label: {
        fontSize: 20,
        position: 'rt',  // possible values are 'lft', 'rt', 'top', 'bot'
        offset: [-80, 20]   // (in pixels)
      }
      });
var yaxis = board0.create('axis', [[0, 0], [0, 1]], 
      {name:'', 
      withLabel: true, 
      label: {
        fontSize: 20,
        position: 'rt',  // possible values are 'lft', 'rt', 'top', 'bot'
        offset: [-120, -20]   // (in pixels)
        }
      });   

var speed = 1;
smartdown.setVariable('Speed', 1);
smartdown.setVariable('distanceToggle', false);
smartdown.setVariable('speedToggle', false);

 
var d = function(t) { return speed * t; };
var d_graph = board0.create('functiongraph', [d,-60,60], {strokeColor:'#DDDDDD', strokeWidth:2});
var s = function(x) { return speed; }
var s_graph = board0.create('functiongraph', [s,-60,60], {strokeColor:'#DDDDDD', strokeWidth:2});


var t1 = board0.create('glider', [2, 0, xaxis], {name: '', size:5});
var t2 = board0.create('glider', [4, 0, xaxis], {name: '', size:5, color:'green'});

var d1 = board0.create('point', [
    function() { return t1.X(); },
    function() { return d(t1.X()); } 
  ], {name:'', color:'blue', fixed:true, size:2, visible:false});

var d2 = board0.create('point', [
    function() { return t2.X(); },
    function() { return d(t2.X()); } 
  ], {name:'', color:'blue', fixed:true, size:2, visible:false});

var dline = board0.create('line', [d1, d2], {strokeColor:'blue', straightFirst:false, straightLast:false, visible:false});

var d3 = board0.create('point', [
    function() { return t2.X(); },
    function() { return d(t1.X()); } 
  ], {name:'', color:'blue', fixed:true, size:2, visible:false});

var drise = board0.create('line', [d3, d2], {strokeColor:'black', dash:2, straightFirst:false, straightLast:false, visible:false});
var drun = board0.create('line', [d1, d3], {strokeColor:'black', dash:2, straightFirst:false, straightLast:false, visible:false});

var driseText = board0.create('text', [
  function() { if (t2.X() &gt; t1.X()) { return t2.X() + 0.2; } 
         return t2.X() - 0.8; },
  function() { return (d(t2.X()) - d(t1.X()))/2 + d(t1.X()); },
  'distance'], {fontSize:12, visible:false});

var drunText = board0.create('text', [
  function() { return t1.X() + (t2.X() - t1.X())/2; },
  function() { if (t2.X() &gt; t1.X()) { return d(t1.X()) - 0.1;} 
                return d(t1.X()) + 0.3; },
  'time'], {fontSize:12, visible:false});

var dslopeText = board0.create('text', [
  function() { if (t2.X() &gt; t1.X()) { return t1.X() + (t2.X() - t1.X())/2 - 1.5; } 
         return t1.X() + (t2.X() - t1.X())/2 + 0.2; },
  function() { return (d(t2.X()) - d(t1.X()))/2 + d(t1.X()); },
  'slope = rate'], {fontSize:12, visible:false});

var distanceOn = false;
var turnOffDistance = function() {
  d1.setAttribute({visible:false});
  d2.setAttribute({visible:false});
  dline.setAttribute({visible:false});
  drise.setAttribute({visible:false});
  driseText.setAttribute({visible:false});
  drun.setAttribute({visible:false});
  drunText.setAttribute({visible:false});
  dslopeText.setAttribute({visible:false});
}

var turnOnDistance = function() {
  d1.setAttribute({visible:true});
  d2.setAttribute({visible:true});
  dline.setAttribute({visible:true});
  drise.setAttribute({visible:true});
  driseText.setAttribute({visible:true});
  drun.setAttribute({visible:true});
  drunText.setAttribute({visible:true});
  dslopeText.setAttribute({visible:true});
}

var s1 = board0.create('point', [
    function() { return t1.X(); },
    s 
  ], {name:'', fixed:true, visible:false});

var s2 = board0.create('point', [
    function() { return t2.X(); },
    s
  ], {name:'', fixed:true, visible:false});

var srect = board0.create('polygon',[t1,s1,s2,t2],{fillColor:'#7700FF',visible:false});

var slengthText = board0.create('text', [
  function() { return t1.X() + (t2.X() - t1.X())/2 - 0.3; },
  function() { return speed + 0.3; },
  'time'], {fontSize:12, visible:false});

var sheightText = board0.create('text', [
  function() { if (t2.X() &gt; t1.X()) { return t2.X() + 0.2; } 
                  return t2.X() - 0.3; },
  function() { return speed/2; },
  'rate'], {fontSize:12, visible:false});

var sareaText = board0.create('text', [
  function() { return t1.X() + (t2.X() - t1.X())/2 - 0.3; },
  function() { return speed/2 + 0.2; },
  'distance'], {fontSize:12, visible:false});

var speedOn = false;
var turnOffSpeed = function() {
  srect.setAttribute({visible:false});
  slengthText.setAttribute({visible:false});
  sheightText.setAttribute({visible:false});
  sareaText.setAttribute({visible:false});
}

var turnOnSpeed = function() {
  srect.setAttribute({visible:true});
  slengthText.setAttribute({visible:true});
  sheightText.setAttribute({visible:true});
  sareaText.setAttribute({visible:true});
}

this.dependOn = ['Speed','distanceToggle','speedToggle'];
this.depend = function() {
  if (env.distanceToggle == true) {
    if (distanceOn) { 
      turnOffDistance();
      distanceOn = false;
    }
    else {
      turnOnDistance();
      distanceOn = true;
    }
    smartdown.setVariable('distanceToggle',false);
  }
    
  if (env.speedToggle == true) {
    if (speedOn) { 
      turnOffSpeed();
      speedOn = false;
    }
    else {
      turnOnSpeed();
      speedOn = true;
    }
    smartdown.setVariable('speedToggle',false);
  }

  board0.suspendUpdate();
  speed = parseFloat(env.Speed);
  board0.unsuspendUpdate();
};

````
[show slope](:=distanceToggle=true) [show area](:=speedToggle=true) Rate [](:-Speed/0/3/0.1) [](:!Speed)

# :::: instructions1
- Drag the red and green dots to the left and the right to adjust the time period. 
- Click the buttons!
- Use the slider to adjust the speed.
# ::::

So slopes and areas are two different geometric ways of expressing the same relationship.  They are inverses, just like the multiplicaton and division that they model.  It's both obvious and at the same time strangely a lot to take in.  It's easy to see that the value of *time* is the same in both cases.  The value of *rate* is also the same, though in one case it's a slope and in the other is a vertical length.  Similarly, the values of *distance* are also the same.  In one case it's a vertical length and in the other its a two dimensional area.  Understanding this geometric relationship is at the heart of calculus and is the heart of the Fundamental Theorem of Calculus.  One goal for my interactive app is that students understand this relationship and can feel it in their gut. 


## Adding More Areas and Slopes

Here are two pictures showing an object that is moving in space.  [see object move](:=play=true)
The picture on the right shows the object moving up and down in space.  The picture on the left is a graph that shows the change in position over time.  Imagine we pick two points on the curve. [show points](:=distanceToggle2=true) The slope of the line through these points tells us the average speed traveled during that time period.  **There is always a corresponding rectangle that expresses the distance traveled as the product of the rate and the time.** [show area](:=speedToggle2=true) It's just two different geometric ways of expressing the same relationship. We can do this for multiple time periods. [multiple periods](:=toggleArray=true) We can make the time periods smaller. [10 time periods](:=segments=10)

```javascript /playable/autoplay
//smartdown.import=https://cdnjs.cloudflare.com/ajax/libs/jsxgraph/0.99.7/jsxgraphcore.js

smartdown.importCssUrl('https://cdnjs.cloudflare.com/ajax/libs/jsxgraph/0.99.7/jsxgraph.css');

const myDiv = this.div;
myDiv.style.width = '100%';
myDiv.style.height = '100%';
myDiv.style.margin = 'auto';
myDiv.innerHTML = `&lt;div id='box2' class='jxgbox' style='height:500px;'&gt;`;

myDiv.innerHTML = `&lt;div id='left' style='height:500px; width:80%; float:left; border:1px solid gray;background:#FFFFFF;border-radius:8px;'&gt;&lt;/div&gt;&lt;div id='right' style='height:500px; width:19%; float:left; border: 1px solid gray;background:#CCEEFF;border-radius:8px;';&gt;&lt;/div&gt;`;

let workspaceDivWidth = 0.80;
let pictureDivWidth = 0.19;
let pictureDivHeight = 500;

JXG.Options.axis.ticks.majorHeight = 40;
// create the board
board1 = JXG.JSXGraph.initBoard('left', {boundingbox:[-1,16,8,-4], keepaspectratio:false, axis:false});

var xaxis = board1.create('axis', [[0, 0], [1,0]], 
      {name:'t', 
      withLabel: true,
      label: {
        fontSize: 20,
        position: 'rt',  // possible values are 'lft', 'rt', 'top', 'bot'
        offset: [-20, 20]   // (in pixels)
      }
      });
var yaxis = board1.create('axis', [[0, 0], [0, 1]], 
      {name:'d', 
      withLabel: true, 
      label: {
        fontSize: 20,
        position: 'rt',  // possible values are 'lft', 'rt', 'top', 'bot'
        offset: [-30, -20]   // (in pixels)
        }
      });   


var d = function(t) { return Math.pow(t-4,4)/8 - 2 * (t-4) * (t-4) + 12; };
var d_graph = board1.create('functiongraph', [d,0,8], {strokeColor:'#DDDDDD', strokeWidth:2});
var dText = board1.create('text', [1.5,7, 'Curve A']);
var s = function(t) { return 4 * Math.pow(t-4,3)/8 - 4 * (t-4); }
var s_graph = board1.create('functiongraph', [s,0,8], {strokeColor:'purple', strokeWidth:4, visible:false});
var sText = board1.create('text', [1.5,-2, 'Curve B'],{visible:false});
let t = board1.create('point', [0,0], {visible:false});
var p = board1.create('point', [
  function() { return t.X(); }, 
  function() { return d(t.X()); }], {color:'blue', name:''});

var tinylines = board1.create('curve', [[0],[0]],{strokecolor:'blue', strokeWidth:2, visible:false}); 
tinylines.updateDataArray = function() { 

    let delta = 8/N;
    let x = [];
    let y = [];
    for (let i=0; i &lt;= 8.01; i += delta) {
        x.push(i);
        y.push(d(i));
    }
    this.dataX = x;
    this.dataY = y;
};


var rectangles = board1.create('curve', [[0],[0]],{fillColor:'#7700FF', fillOpacity:0.3, visible:false});
rectangles.updateDataArray = function() {

    let delta = 8/N;
    let x = [0];
    let y = [0];
    for (let i=0; i &lt; 8; i += delta) {
        let slope = (d(i + delta) - d(i)) / delta ;
        x.push(i);  // four points of our rectangle
        y.push(slope);

        x.push(i + delta);
        y.push(slope);

        x.push(i + delta);
        y.push(0);
    }
    this.dataX = x;
    this.dataY = y;
};

var t1 = board1.create('point', [2, 0], {name: '', size:3, color:'blue', visible:false});
var t2 = board1.create('point', [4, 0], {name: '', size:3, color:'blue', visible:false});

var d1 = board1.create('point', [
    function() { return t1.X(); },
    function() { return d(t1.X()); } 
  ], {name:'', color:'blue', fixed:true, size:2, visible:false});

var d2 = board1.create('point', [
    function() { return t2.X(); },
    function() { return d(t2.X()); } 
  ], {name:'', color:'blue', fixed:true, size:2, visible:false});

var dline = board1.create('line', [d1, d2], {strokeColor:'blue', straightFirst:false, straightLast:false, visible:false});

var d3 = board1.create('point', [
    function() { return t2.X(); },
    function() { return d(t1.X()); } 
  ], {name:'', color:'blue', fixed:true, size:2, visible:false});

var drise = board1.create('line', [d3, d2], {strokeColor:'black', dash:2, straightFirst:false, straightLast:false, visible:false});
var drun = board1.create('line', [d1, d3], {strokeColor:'black', dash:2, straightFirst:false, straightLast:false, visible:false});

var driseText = board1.create('text', [
  function() { if (t2.X() &gt; t1.X()) { return t2.X() + 0.1; } 
         return t2.X() - 0.3; },
  function() { return (d(t2.X()) - d(t1.X()))/2 + d(t1.X()); },
  'd'], {fontSize:12, visible:false});

var drunText = board1.create('text', [
  function() { return t1.X() + (t2.X() - t1.X())/2; },
  function() { if (t2.X() &gt; t1.X()) { return d(t1.X()) - 0.5;} 
                return d(t1.X()) + 0.10; },
  't'], {fontSize:12, visible:false});

var dslopeText = board1.create('text', [
  function() { if (t2.X() &gt; t1.X()) { return t1.X() + (t2.X() - t1.X())/2 - 0.5; } 
         return t1.X() + (t2.X() - t1.X())/2 + 0.2; },
  function() { return (d(t2.X()) - d(t1.X()))/2 + d(t1.X()); },
  'slope = r'], {fontSize:12, visible:false});

var slope = (d(t2.X()) - d(t1.X())) / (t2.X() - t1.X());
var s1 = board1.create('point', [t1.X(), slope], {name:'', fixed:true, visible:false});

var s2 = board1.create('point', [t2.X(), slope], {name:'', fixed:true, visible:false});

var srect = board1.create('polygon',[t1,s1,s2,t2],{fillColor:'#7700FF',visible:false});

var slengthText = board1.create('text', [t1.X() + (t2.X() - t1.X())/2, slope + 0.8, 't'], {fontSize:12, visible:false});

var sheightText = board1.create('text', [t2.X() + 0.1, slope/2, 'r'], {fontSize:12, visible:false});

var sareaText = board1.create('text', [ t1.X() + (t2.X() - t1.X())/2,  slope/2 + 0.2, 'd'], {fontSize:12, visible:false});


let board2 = JXG.JSXGraph.initBoard('right', {boundingbox:[-1,16,2,-4], keepaspectratio:false, axis:false});

var board2Yaxis = board2.create('axis', [[0, 0], [0, 1]], 
      {name:'d', 
      withLabel: true, 
      label: {
        fontSize: 20,
        position: 'rt',  // possible values are 'lft', 'rt', 'top', 'bot'
        offset: [-30, -20]   // (in pixels)
        }
      });  

var board2Xaxis = board2.create('axis', [[0, 0], [1,0]], 
      {name:'', 
      withLabel: false,
      label: {
        fontSize: 20,
        position: 'rt',  // possible values are 'lft', 'rt', 'top', 'bot'
        offset: [-20, 20]   // (in pixels)
      },
      majorHeight:0
      });

board2Xaxis.removeAllTicks();

board1.addChild(board2);

var p2 = board2.create('point', [
  1.2, 
  function() { return p.Y(); }], {color:'blue', name:'', size:6});

// let rocketurl = 'https://gist.githubusercontent.com/wildthinkslaboratory/ac98c0bb68ccf7528dc39fa1922d2bdb/raw/cab590371e4346929cf9096e53d163e772e1d132/rocket.png';
// let rocket = board1.create('image',[rocketurl, [0.9,function() { return workspace.getArea() - 3000; }], [0.2,3000]]);

// let p2 = board1.create('point',[1.2, 0],{visible:true});
// let p3 = board1.create('point',[1.2, function() { return workspace.getArea(); }],{visible:false});

// let dimensionLine = board1.create('segment', [p2,p3], {
//   strokeColor:'#999999', 
//   strokeWidth:2, 
//   firstArrow:true, 
//   lastArrow:true, 
//   visible:true});

// let dimensionText = board1.create('text', [
//   1.3,
//   function () { return workspace.getArea() / 2; },
//   function() { return workspace.getArea().toFixed(0); }
// ],{ strokeColor:'#999999', fontSize: 15, visible:true});


smartdown.setVariable('segments', 3);
var N = 3;
var oldN = 3;
smartdown.setVariable('distanceToggle2', false);
smartdown.setVariable('speedToggle2', false);
smartdown.setVariable('toggleArray', false);
smartdown.setVariable('toggleCurveB', false);
smartdown.setVariable('play', false);
var speedOn = false;
var distanceOn = false;


this.sizeChanged = function() {     
  board1.resizeContainer(myDiv.offsetWidth * workspaceDivWidth, pictureDivHeight);
  board2.resizeContainer(myDiv.offsetWidth * pictureDivWidth, pictureDivHeight);
};

var move = function() { 
  t.moveTo([8,0],1000, {effect: '--', callback: function() {  t.moveTo([0,0]); } } ); 
};

// get the number of triangles from smartdown cell
this.dependOn = ['segments','distanceToggle2','speedToggle2', 'toggleArray', 'toggleCurveB', 'play'];
this.depend = function() {

  board1.suspendUpdate();

  if (env.play == true) {
    smartdown.setVariable('play', false);
    move();

  }

  if (env.distanceToggle2 == true &amp;&amp; env.toggleArray == false) {
    d1.setAttribute({visible:true});
    d2.setAttribute({visible:true});
    drise.setAttribute({visible:true});
    drun.setAttribute({visible:true});
    dline.setAttribute({visible:true});
    driseText.setAttribute({visible:true});
    drunText.setAttribute({visible:true});
    dslopeText.setAttribute({visible:true});
  }
  
  if (env.speedToggle2 == true &amp;&amp; env.toggleArray == false) {
    smartdown.setVariable('segments', 4);
  }

  if (env.toggleArray == true) {
    tinylines.setAttribute({visible:true});
    rectangles.setAttribute({visible:true});
    d1.setAttribute({visible:false});
    d2.setAttribute({visible:false});
  }

  var P = parseInt(env.segments);
  if (P != N) {
    oldN = N;
    N = P;    
  }
  
  if (N == 4) {
    drise.setAttribute({visible:true});
    drun.setAttribute({visible:true});
    dline.setAttribute({visible:true});
    driseText.setAttribute({visible:true});
    drunText.setAttribute({visible:true});
    dslopeText.setAttribute({visible:true});
    srect.setAttribute({visible:true});
    slengthText.setAttribute({visible:true});
    sheightText.setAttribute({visible:true});
    sareaText.setAttribute({visible:true});
  }
  else {
    if (oldN == 4) {
      drise.setAttribute({visible:false});
      drun.setAttribute({visible:false});
      dline.setAttribute({visible:false});
      driseText.setAttribute({visible:false});
      drunText.setAttribute({visible:false});
      dslopeText.setAttribute({visible:false});
      srect.setAttribute({visible:false});
      slengthText.setAttribute({visible:false});
      sheightText.setAttribute({visible:false});
      sareaText.setAttribute({visible:false});
    }
  }

  if (env.toggleCurveB == true) {
    s_graph.setAttribute({visible:true});
    sText.setAttribute({visible:true});
  }

  board1.unsuspendUpdate();
};


```
Number of Time Periods [](:-segments/1/100/1) [](:!segments) [Application Instructions](::instructions2/tooltip)


# :::: instructions2
Drag the slider to the left and right.
# ::::

As the time periods get very small, the rectangles define a new function that relates to our original curve.  It's related by the function $d = r \cdot t$.  [show rectangle curve](:=toggleCurveB=true) This function gives the height of our rectangles. Remember that the height of each skinny rectangle is the average speed the object travels during a very short time period.  As these rectangles get skinnier, this new curve becomes our speed curve.

So this gives you a small glimpse of how this idea might be developed.  It would need to be developed more slowly together with motivation for why you might be interested in slopes and areas in the first place and how slopes and areas relate to a function.  But this is the nucleus of an idea.</content><author><name>Heidi Dixon</name></author><summary type="html">When students finish their high school calculus classes, they will likely remember many of the short cut rules for how to take the derivative of different types of functions (definitely useful!). They often don't remember how these rules were derived and they may not remember the Fundamental Theorem of Calculus or have any intuition as to why it is true. In other words, they emerge from these classes without intuition or awe about the main ideas of calculus. I'm on a mission to make this better. I want to make an interactive online Calculus Primer. It will be an activity that you do before starting a calculus class that helps build the intuition for what's coming. It will avoid calculus notations and terminology. It will not contain messy algebra. It will focus on geometric models and building intuition. I have a tight time schedule since my oldest son will start his first calculus class this summer and I want to get him off to a good start. This post is the first in a series. I've got more ideas than I can fit into one post and I have just as many unanswered questions. ### My First Idea: Geometric Intuition for The Fundamental Theorem of Calculus Calculus is a fancy way of studying rates of change. Kids start learning about rates in middle school. # --outlinebox **Example** If a kid eats three slices of pizza a day, how many slices will they eat in 5 days? **Solution** The total pizza eaten is equal to the number of slices per day times the number of days. $$15 = 3 \; \frac{\text{slices}}{\text{day}} \; \times 5 \; \text{days}$$ # --outlinebox In this case, the amount of pizza is changing relative to the number of days. More generally, we have some quantity $Y$ that is changing relative to some other quantity $X$. The total change in $Y$ is equal to the rate of change $\frac{\Delta Y}{\Delta X}$ times the units of $X$. In practice, I think the most intuitive rate of change problem to think about is a moving object. The distance traveled by an object is equal to the rate (or speed) of the object times the time spent moving. $$\text{distance} = \text{rate} \; \times \; \text{time}. $$ For now, let's assume we're talking about a moving car and just remember that all of this can be generalized to anything that has a rate of change. So we're talking about a moving car, and we have this relationship $d = r \times t$, but there are two ways to write it and they each have a different geometric representation. If we know the rate and the time, then finding the distance is a multiplication problem which we can model as an area problem. [show area](:=speedToggle=true) If the length and width of the rectangle have the values of *rate* and *time*, then the area of the rectangle will be the *distance* traveled. Now imagine instead that we have the distance and the time and we want to find the rate. We write this formula as $r = \frac{d}{t}$. Finding the rate in terms of distance and time is a division problem which we can model as the slope of a line. [show slope](:=distanceToggle=true) [Application Instructions](::instructions1/tooltip) ```javascript /playable/autoplay //smartdown.import=https://cdnjs.cloudflare.com/ajax/libs/jsxgraph/0.99.7/jsxgraphcore.js smartdown.importCssUrl('https://cdnjs.cloudflare.com/ajax/libs/jsxgraph/0.99.7/jsxgraph.css'); const myDiv = this.div; myDiv.style.width = '100%'; myDiv.style.height = '100%'; myDiv.style.margin = 'auto'; myDiv.innerHTML = ``; JXG.Options.axis.ticks.majorHeight = 40; // create the board board0 = JXG.JSXGraph.initBoard('box1', {boundingbox:[-2,7,10,-1], keepaspectratio:true, axis:false}); var xaxis = board0.create('axis', [[0, 0], [1,0]], {name:'time (s)', withLabel: true, label: { fontSize: 20, position: 'rt', // possible values are 'lft', 'rt', 'top', 'bot' offset: [-80, 20] // (in pixels) } }); var yaxis = board0.create('axis', [[0, 0], [0, 1]], {name:'', withLabel: true, label: { fontSize: 20, position: 'rt', // possible values are 'lft', 'rt', 'top', 'bot' offset: [-120, -20] // (in pixels) } }); var speed = 1; smartdown.setVariable('Speed', 1); smartdown.setVariable('distanceToggle', false); smartdown.setVariable('speedToggle', false); var d = function(t) { return speed * t; }; var d_graph = board0.create('functiongraph', [d,-60,60], {strokeColor:'#DDDDDD', strokeWidth:2}); var s = function(x) { return speed; } var s_graph = board0.create('functiongraph', [s,-60,60], {strokeColor:'#DDDDDD', strokeWidth:2}); var t1 = board0.create('glider', [2, 0, xaxis], {name: '', size:5}); var t2 = board0.create('glider', [4, 0, xaxis], {name: '', size:5, color:'green'}); var d1 = board0.create('point', [ function() { return t1.X(); }, function() { return d(t1.X()); } ], {name:'', color:'blue', fixed:true, size:2, visible:false}); var d2 = board0.create('point', [ function() { return t2.X(); }, function() { return d(t2.X()); } ], {name:'', color:'blue', fixed:true, size:2, visible:false}); var dline = board0.create('line', [d1, d2], {strokeColor:'blue', straightFirst:false, straightLast:false, visible:false}); var d3 = board0.create('point', [ function() { return t2.X(); }, function() { return d(t1.X()); } ], {name:'', color:'blue', fixed:true, size:2, visible:false}); var drise = board0.create('line', [d3, d2], {strokeColor:'black', dash:2, straightFirst:false, straightLast:false, visible:false}); var drun = board0.create('line', [d1, d3], {strokeColor:'black', dash:2, straightFirst:false, straightLast:false, visible:false}); var driseText = board0.create('text', [ function() { if (t2.X() &gt; t1.X()) { return t2.X() + 0.2; } return t2.X() - 0.8; }, function() { return (d(t2.X()) - d(t1.X()))/2 + d(t1.X()); }, 'distance'], {fontSize:12, visible:false}); var drunText = board0.create('text', [ function() { return t1.X() + (t2.X() - t1.X())/2; }, function() { if (t2.X() &gt; t1.X()) { return d(t1.X()) - 0.1;} return d(t1.X()) + 0.3; }, 'time'], {fontSize:12, visible:false}); var dslopeText = board0.create('text', [ function() { if (t2.X() &gt; t1.X()) { return t1.X() + (t2.X() - t1.X())/2 - 1.5; } return t1.X() + (t2.X() - t1.X())/2 + 0.2; }, function() { return (d(t2.X()) - d(t1.X()))/2 + d(t1.X()); }, 'slope = rate'], {fontSize:12, visible:false}); var distanceOn = false; var turnOffDistance = function() { d1.setAttribute({visible:false}); d2.setAttribute({visible:false}); dline.setAttribute({visible:false}); drise.setAttribute({visible:false}); driseText.setAttribute({visible:false}); drun.setAttribute({visible:false}); drunText.setAttribute({visible:false}); dslopeText.setAttribute({visible:false}); } var turnOnDistance = function() { d1.setAttribute({visible:true}); d2.setAttribute({visible:true}); dline.setAttribute({visible:true}); drise.setAttribute({visible:true}); driseText.setAttribute({visible:true}); drun.setAttribute({visible:true}); drunText.setAttribute({visible:true}); dslopeText.setAttribute({visible:true}); } var s1 = board0.create('point', [ function() { return t1.X(); }, s ], {name:'', fixed:true, visible:false}); var s2 = board0.create('point', [ function() { return t2.X(); }, s ], {name:'', fixed:true, visible:false}); var srect = board0.create('polygon',[t1,s1,s2,t2],{fillColor:'#7700FF',visible:false}); var slengthText = board0.create('text', [ function() { return t1.X() + (t2.X() - t1.X())/2 - 0.3; }, function() { return speed + 0.3; }, 'time'], {fontSize:12, visible:false}); var sheightText = board0.create('text', [ function() { if (t2.X() &gt; t1.X()) { return t2.X() + 0.2; } return t2.X() - 0.3; }, function() { return speed/2; }, 'rate'], {fontSize:12, visible:false}); var sareaText = board0.create('text', [ function() { return t1.X() + (t2.X() - t1.X())/2 - 0.3; }, function() { return speed/2 + 0.2; }, 'distance'], {fontSize:12, visible:false}); var speedOn = false; var turnOffSpeed = function() { srect.setAttribute({visible:false}); slengthText.setAttribute({visible:false}); sheightText.setAttribute({visible:false}); sareaText.setAttribute({visible:false}); } var turnOnSpeed = function() { srect.setAttribute({visible:true}); slengthText.setAttribute({visible:true}); sheightText.setAttribute({visible:true}); sareaText.setAttribute({visible:true}); } this.dependOn = ['Speed','distanceToggle','speedToggle']; this.depend = function() { if (env.distanceToggle == true) { if (distanceOn) { turnOffDistance(); distanceOn = false; } else { turnOnDistance(); distanceOn = true; } smartdown.setVariable('distanceToggle',false); } if (env.speedToggle == true) { if (speedOn) { turnOffSpeed(); speedOn = false; } else { turnOnSpeed(); speedOn = true; } smartdown.setVariable('speedToggle',false); } board0.suspendUpdate(); speed = parseFloat(env.Speed); board0.unsuspendUpdate(); }; ```` [show slope](:=distanceToggle=true) [show area](:=speedToggle=true) Rate [](:-Speed/0/3/0.1) [](:!Speed) # :::: instructions1 - Drag the red and green dots to the left and the right to adjust the time period. - Click the buttons! - Use the slider to adjust the speed. # :::: So slopes and areas are two different geometric ways of expressing the same relationship. They are inverses, just like the multiplicaton and division that they model. It's both obvious and at the same time strangely a lot to take in. It's easy to see that the value of *time* is the same in both cases. The value of *rate* is also the same, though in one case it's a slope and in the other is a vertical length. Similarly, the values of *distance* are also the same. In one case it's a vertical length and in the other its a two dimensional area. Understanding this geometric relationship is at the heart of calculus and is the heart of the Fundamental Theorem of Calculus. One goal for my interactive app is that students understand this relationship and can feel it in their gut. ## Adding More Areas and Slopes Here are two pictures showing an object that is moving in space. [see object move](:=play=true) The picture on the right shows the object moving up and down in space. The picture on the left is a graph that shows the change in position over time. Imagine we pick two points on the curve. [show points](:=distanceToggle2=true) The slope of the line through these points tells us the average speed traveled during that time period. **There is always a corresponding rectangle that expresses the distance traveled as the product of the rate and the time.** [show area](:=speedToggle2=true) It's just two different geometric ways of expressing the same relationship. We can do this for multiple time periods. [multiple periods](:=toggleArray=true) We can make the time periods smaller. [10 time periods](:=segments=10) ```javascript /playable/autoplay //smartdown.import=https://cdnjs.cloudflare.com/ajax/libs/jsxgraph/0.99.7/jsxgraphcore.js smartdown.importCssUrl('https://cdnjs.cloudflare.com/ajax/libs/jsxgraph/0.99.7/jsxgraph.css'); const myDiv = this.div; myDiv.style.width = '100%'; myDiv.style.height = '100%'; myDiv.style.margin = 'auto'; myDiv.innerHTML = ``; myDiv.innerHTML = ``; let workspaceDivWidth = 0.80; let pictureDivWidth = 0.19; let pictureDivHeight = 500; JXG.Options.axis.ticks.majorHeight = 40; // create the board board1 = JXG.JSXGraph.initBoard('left', {boundingbox:[-1,16,8,-4], keepaspectratio:false, axis:false}); var xaxis = board1.create('axis', [[0, 0], [1,0]], {name:'t', withLabel: true, label: { fontSize: 20, position: 'rt', // possible values are 'lft', 'rt', 'top', 'bot' offset: [-20, 20] // (in pixels) } }); var yaxis = board1.create('axis', [[0, 0], [0, 1]], {name:'d', withLabel: true, label: { fontSize: 20, position: 'rt', // possible values are 'lft', 'rt', 'top', 'bot' offset: [-30, -20] // (in pixels) } }); var d = function(t) { return Math.pow(t-4,4)/8 - 2 * (t-4) * (t-4) + 12; }; var d_graph = board1.create('functiongraph', [d,0,8], {strokeColor:'#DDDDDD', strokeWidth:2}); var dText = board1.create('text', [1.5,7, 'Curve A']); var s = function(t) { return 4 * Math.pow(t-4,3)/8 - 4 * (t-4); } var s_graph = board1.create('functiongraph', [s,0,8], {strokeColor:'purple', strokeWidth:4, visible:false}); var sText = board1.create('text', [1.5,-2, 'Curve B'],{visible:false}); let t = board1.create('point', [0,0], {visible:false}); var p = board1.create('point', [ function() { return t.X(); }, function() { return d(t.X()); }], {color:'blue', name:''}); var tinylines = board1.create('curve', [[0],[0]],{strokecolor:'blue', strokeWidth:2, visible:false}); tinylines.updateDataArray = function() { let delta = 8/N; let x = []; let y = []; for (let i=0; i t1.X()) { return t2.X() + 0.1; } return t2.X() - 0.3; }, function() { return (d(t2.X()) - d(t1.X()))/2 + d(t1.X()); }, 'd'], {fontSize:12, visible:false}); var drunText = board1.create('text', [ function() { return t1.X() + (t2.X() - t1.X())/2; }, function() { if (t2.X() &gt; t1.X()) { return d(t1.X()) - 0.5;} return d(t1.X()) + 0.10; }, 't'], {fontSize:12, visible:false}); var dslopeText = board1.create('text', [ function() { if (t2.X() &gt; t1.X()) { return t1.X() + (t2.X() - t1.X())/2 - 0.5; } return t1.X() + (t2.X() - t1.X())/2 + 0.2; }, function() { return (d(t2.X()) - d(t1.X()))/2 + d(t1.X()); }, 'slope = r'], {fontSize:12, visible:false}); var slope = (d(t2.X()) - d(t1.X())) / (t2.X() - t1.X()); var s1 = board1.create('point', [t1.X(), slope], {name:'', fixed:true, visible:false}); var s2 = board1.create('point', [t2.X(), slope], {name:'', fixed:true, visible:false}); var srect = board1.create('polygon',[t1,s1,s2,t2],{fillColor:'#7700FF',visible:false}); var slengthText = board1.create('text', [t1.X() + (t2.X() - t1.X())/2, slope + 0.8, 't'], {fontSize:12, visible:false}); var sheightText = board1.create('text', [t2.X() + 0.1, slope/2, 'r'], {fontSize:12, visible:false}); var sareaText = board1.create('text', [ t1.X() + (t2.X() - t1.X())/2, slope/2 + 0.2, 'd'], {fontSize:12, visible:false}); let board2 = JXG.JSXGraph.initBoard('right', {boundingbox:[-1,16,2,-4], keepaspectratio:false, axis:false}); var board2Yaxis = board2.create('axis', [[0, 0], [0, 1]], {name:'d', withLabel: true, label: { fontSize: 20, position: 'rt', // possible values are 'lft', 'rt', 'top', 'bot' offset: [-30, -20] // (in pixels) } }); var board2Xaxis = board2.create('axis', [[0, 0], [1,0]], {name:'', withLabel: false, label: { fontSize: 20, position: 'rt', // possible values are 'lft', 'rt', 'top', 'bot' offset: [-20, 20] // (in pixels) }, majorHeight:0 }); board2Xaxis.removeAllTicks(); board1.addChild(board2); var p2 = board2.create('point', [ 1.2, function() { return p.Y(); }], {color:'blue', name:'', size:6}); // let rocketurl = 'https://gist.githubusercontent.com/wildthinkslaboratory/ac98c0bb68ccf7528dc39fa1922d2bdb/raw/cab590371e4346929cf9096e53d163e772e1d132/rocket.png'; // let rocket = board1.create('image',[rocketurl, [0.9,function() { return workspace.getArea() - 3000; }], [0.2,3000]]); // let p2 = board1.create('point',[1.2, 0],{visible:true}); // let p3 = board1.create('point',[1.2, function() { return workspace.getArea(); }],{visible:false}); // let dimensionLine = board1.create('segment', [p2,p3], { // strokeColor:'#999999', // strokeWidth:2, // firstArrow:true, // lastArrow:true, // visible:true}); // let dimensionText = board1.create('text', [ // 1.3, // function () { return workspace.getArea() / 2; }, // function() { return workspace.getArea().toFixed(0); } // ],{ strokeColor:'#999999', fontSize: 15, visible:true}); smartdown.setVariable('segments', 3); var N = 3; var oldN = 3; smartdown.setVariable('distanceToggle2', false); smartdown.setVariable('speedToggle2', false); smartdown.setVariable('toggleArray', false); smartdown.setVariable('toggleCurveB', false); smartdown.setVariable('play', false); var speedOn = false; var distanceOn = false; this.sizeChanged = function() { board1.resizeContainer(myDiv.offsetWidth * workspaceDivWidth, pictureDivHeight); board2.resizeContainer(myDiv.offsetWidth * pictureDivWidth, pictureDivHeight); }; var move = function() { t.moveTo([8,0],1000, {effect: '--', callback: function() { t.moveTo([0,0]); } } ); }; // get the number of triangles from smartdown cell this.dependOn = ['segments','distanceToggle2','speedToggle2', 'toggleArray', 'toggleCurveB', 'play']; this.depend = function() { board1.suspendUpdate(); if (env.play == true) { smartdown.setVariable('play', false); move(); } if (env.distanceToggle2 == true &amp;&amp; env.toggleArray == false) { d1.setAttribute({visible:true}); d2.setAttribute({visible:true}); drise.setAttribute({visible:true}); drun.setAttribute({visible:true}); dline.setAttribute({visible:true}); driseText.setAttribute({visible:true}); drunText.setAttribute({visible:true}); dslopeText.setAttribute({visible:true}); } if (env.speedToggle2 == true &amp;&amp; env.toggleArray == false) { smartdown.setVariable('segments', 4); } if (env.toggleArray == true) { tinylines.setAttribute({visible:true}); rectangles.setAttribute({visible:true}); d1.setAttribute({visible:false}); d2.setAttribute({visible:false}); } var P = parseInt(env.segments); if (P != N) { oldN = N; N = P; } if (N == 4) { drise.setAttribute({visible:true}); drun.setAttribute({visible:true}); dline.setAttribute({visible:true}); driseText.setAttribute({visible:true}); drunText.setAttribute({visible:true}); dslopeText.setAttribute({visible:true}); srect.setAttribute({visible:true}); slengthText.setAttribute({visible:true}); sheightText.setAttribute({visible:true}); sareaText.setAttribute({visible:true}); } else { if (oldN == 4) { drise.setAttribute({visible:false}); drun.setAttribute({visible:false}); dline.setAttribute({visible:false}); driseText.setAttribute({visible:false}); drunText.setAttribute({visible:false}); dslopeText.setAttribute({visible:false}); srect.setAttribute({visible:false}); slengthText.setAttribute({visible:false}); sheightText.setAttribute({visible:false}); sareaText.setAttribute({visible:false}); } } if (env.toggleCurveB == true) { s_graph.setAttribute({visible:true}); sText.setAttribute({visible:true}); } board1.unsuspendUpdate(); }; ``` Number of Time Periods [](:-segments/1/100/1) [](:!segments) [Application Instructions](::instructions2/tooltip) # :::: instructions2 Drag the slider to the left and right. # :::: As the time periods get very small, the rectangles define a new function that relates to our original curve. It's related by the function $d = r \cdot t$. [show rectangle curve](:=toggleCurveB=true) This function gives the height of our rectangles. Remember that the height of each skinny rectangle is the average speed the object travels during a very short time period. As these rectangles get skinnier, this new curve becomes our speed curve. So this gives you a small glimpse of how this idea might be developed. It would need to be developed more slowly together with motivation for why you might be interested in slopes and areas in the first place and how slopes and areas relate to a function. But this is the nucleus of an idea.</summary></entry></feed>